//-----------------------------------------------------------------------------
// Torque X Game Engine
// Copyright © GarageGames.com, Inc.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using System.Diagnostics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using GarageGames.Torque.Core;
using GarageGames.Torque.Util;
using GarageGames.Torque.Materials;
using GarageGames.Torque.SceneGraph;
using GarageGames.Torque.GFX;
using GarageGames.Torque.RenderManager;
using GarageGames.Torque.MathUtil;
using GarageGames.Torque.Sim;
using GarageGames.Torque.Lighting;
using System.Collections;



namespace GarageGames.Torque.T2D
{
    /// <summary>
    /// T2DParticleEffectData describes the operation of a T2DParticleEffect.
    /// </summary>
    public class T2DParticleEffectData : TorqueBase, IDisposable
    {
        #region Constructors

        public T2DParticleEffectData()
        {
            // Create/Register Graph Properties.
            _particleLife = new T2DKeyGraph_Scale();
            _quantity = new T2DKeyGraph_Scale();
            _sizeX = new T2DKeyGraph_Scale();
            _sizeY = new T2DKeyGraph_Scale();
            _speed = new T2DKeyGraph_Scale();
            _spin = new T2DKeyGraph_Scale();
            _fixedForce = new T2DKeyGraph_Scale();
            _randomMotion = new T2DKeyGraph_Scale();
            _emissionForce = new T2DKeyGraph_BaseVariation(5.0f);
            _emissionAngle = new T2DKeyGraph_BaseVariation(0.0f);
            _emissionArc = new T2DKeyGraph_BaseVariation(360.0f);
            _visibility = new T2DKeyGraph_Scale();

            // Reset Effect Values.
            ResetValues();
        }

        #endregion


        #region Public properties, operators, constants, and enums

        #region Enumerations

        // -------------------------------------------------------------
        // Enumerations.
        // -------------------------------------------------------------

        // Emitter-Data Order Change.
        public enum EmitterDataOrderChange
        {
            First,      // First in order.
            Last,       // Last in order.
            Next,       // Next in order.
            Previous    // Previous in order.
        }



        /// <summary>
        /// Life cycle parameters for particle effect.
        /// </summary>
        public enum EffectLifeMode
        {
            /// <summary>
            /// Effect will continue to emit particles even after it's lifetime has expired, using
            /// values from the tail end of it's lifetime for new particles.
            /// Effect will stay in existence until explicitly removed, even after it finishes.
            /// </summary>
            Infinite,
            /// <summary>
            /// When effect reaches the end of it's lifetime it will start over at the start.
            /// Effect will stay in existence until explicitly removed, even after it finishes.
            /// </summary>
            Cycle,
            /// <summary>
            /// When effect reaches the end of it's lifetime it will stop playing.
            /// Effect will stay in existence until explicitly removed, even after it finishes.
            /// </summary>
            Stop,
            /// <summary>
            /// When effect reaches the end of it's lifetime it will remove itself from the scene.
            /// </summary>
            Kill,
        }

        #endregion //Enumerations

        #region Delegates

        // -------------------------------------------------------------
        // Delegates.
        // -------------------------------------------------------------
        public delegate void EmitterListChangedEvent(T2DParticleEffectData effectData);



        public event EmitterListChangedEvent OnEmitterListChanged;

        #endregion //Delegates

        #region T2DKeyGraph Properties

        // -------------------------------------------------------------
        // Graph Properties.
        // -------------------------------------------------------------

        /// <summary>
        /// Scale the lifetime of particles generated by emitters of this effect
        /// based on the lifetime of the effect.
        /// </summary>
        public T2DKeyGraph ParticleLifeScale
        {
            get
            {
                return _particleLife.Scale;
            }
        }



        /// <summary>
        /// Scale the rate of new particles generated by emitters of this effect
        /// based on the lifetime of the effect.
        /// </summary>
        public T2DKeyGraph QuantityScale
        {
            get
            {
                return _quantity.Scale;
            }
        }



        /// <summary>
        /// Scale the width of new particles generated by emitters of this effect
        /// based on the lifetime of the effect.
        /// </summary>
        public T2DKeyGraph SizeXScale
        {
            get
            {
                return _sizeX.Scale;
            }
        }



        /// <summary>
        /// Scale the height of particles generated by emitters of this effect
        /// based on the lifetime of the effect.
        /// </summary>
        public T2DKeyGraph SizeYScale
        {
            get
            {
                return _sizeY.Scale;
            }
        }



        /// <summary>
        /// Scale the speed of particles generated by emitters of this effect
        /// based on the lifetime of the effect.
        /// </summary>
        public T2DKeyGraph SpeedScale
        {
            get
            {
                return _speed.Scale;
            }
        }



        /// <summary>
        /// Scale the rotation rate of particles generated by emitters of this effect
        /// based on the lifetime of the effect.
        /// </summary>
        public T2DKeyGraph SpinScale
        {
            get
            {
                return _spin.Scale;
            }
        }



        /// <summary>
        /// Scale the fixed force applied to particles generated by emitters of this effect
        /// based on the lifetime of the effect.
        /// </summary>
        public T2DKeyGraph FixedForceScale
        {
            get
            {
                return _fixedForce.Scale;
            }
        }



        /// <summary>
        /// Scale the radom velocity added to particles generated by emitters of this effect
        /// based on the lifetime of the effect.
        /// </summary>
        public T2DKeyGraph RandomMotionScale
        {
            get
            {
                return _randomMotion.Scale;
            }
        }



        /// <summary>
        /// Used to determine initial velocity when particle
        /// is first emitted.  Note: if ParticleEmitter.UseEffectEmission is false
        /// then this value is ignored.
        /// </summary>
        public T2DKeyGraph EmissionForceBase
        {
            get
            {
                return _emissionForce.Base;
            }
        }



        /// <summary>
        /// Used to determine initial velocity when particle
        /// is first emitted.  Note: if ParticleEmitter.UseEffectEmission is false
        /// then this value is ignored.
        /// </summary>
        public T2DKeyGraph EmissionForceVariation
        {
            get
            {
                return _emissionForce.Variation;
            }
        }



        /// <summary>
        /// Used to determine emission angle of particles generated by emitters in
        /// this effect.  Note: if ParticleEmitter.UseEffectEmission is false
        /// then this value is ignored.
        /// </summary>
        public T2DKeyGraph EmissionAngleBase
        {
            get
            {
                return _emissionAngle.Base;
            }
        }



        /// <summary>
        /// Used to determine emission angle of particles generated by emitters in
        /// this effect.  Note: if ParticleEmitter.UseEffectEmission is false
        /// then this value is ignored.
        /// </summary>
        public T2DKeyGraph EmissionAngleVariation
        {
            get
            {
                return _emissionAngle.Variation;
            }
        }



        /// <summary>
        /// Used to determine emission angle of particles generated by emitters in
        /// this effect.  Note: if ParticleEmitter.UseEffectEmission is false
        /// then this value is ignored.
        /// </summary>
        public T2DKeyGraph EmissionArcBase
        {
            get
            {
                return _emissionArc.Base;
            }
        }



        /// <summary>
        /// Used to determine emission angle of particles generated by emitters in
        /// this effect.  Note: if ParticleEmitter.UseEffectEmission is false
        /// then this value is ignored.
        /// </summary>
        public T2DKeyGraph EmissionArcVariation
        {
            get
            {
                return _emissionArc.Variation;
            }
        }



        /// <summary>
        /// Scale the visibility of particles generated by emitters of this effect
        /// based on the lifetime of the effect.
        /// </summary>
        public T2DKeyGraph VisibilityScale
        {
            get
            {
                return _visibility.Scale;
            }
        }

        #endregion //T2DKeyGraph Properties

        #region Non-T2DKeyGraph Properties

        // -------------------------------------------------------------
        // Non-Graph Properties.
        // -------------------------------------------------------------

        /// <summary>
        /// Life cycle parameters for particle effect.
        /// </summary>
        public EffectLifeMode LifeMode
        {
            get
            {
                return _effectlifeMode;
            }
            set
            {
                _effectlifeMode = value;
            }
        }



        /// <summary>
        /// Lifetime of effect in seconds.
        /// </summary>
        public float Lifetime
        {
            get
            {
                return _effectLifetime;
            }
            set
            {
                // Sanity.
                Assert.Fatal(_effectLifetime >= 0.0f, "Effect life must be >=0!");

                // Set Effect Lifetime.
                _effectLifetime = value;
            }
        }



        /// <summary>
        /// Number of emitters in this effect.
        /// </summary>
        public int EmitterCount
        {
            get
            {
                return _emitterDataList.Count;
            }
        }



        /// <summary>
        /// List of T2DParticleEmitterData, one for each emitter in the effect.
        /// Note: this interface is here for deserialization purposes only and is
        /// unsupported for any other purpose.
        /// </summary>
        [XmlElement(ElementName = "Emitters")]
        public List<T2DParticleEmitterData> EmitterDataList
        {
            get
            {
                return _emitterDataList;
            }
            set
            {
                _emitterDataList = value;
                EmitterListChanged();
            }
        }

        #endregion //Non-T2DKeyGraph Properties

        #endregion


        #region Public methods

        /// <summary>
        /// Reset to default values.
        /// </summary>
        public virtual void ResetValues()
        {
            // Reset Life-Mode.
            LifeMode = EffectLifeMode.Infinite;

            // Reset LifeTime.
            Lifetime = 0.0f;
        }



        /// <summary>
        ///  Add a new emitter description.
        /// </summary>
        /// <param name="emitterData">Emitter to add.</param>
        public void AddEmitterData(T2DParticleEmitterData emitterData)
        {
            // Add emitter-data to list.
            _emitterDataList.Add(emitterData);

            // Emitter List Changed.
            EmitterListChanged();
        }



        /// <summary>
        /// Remove an emitter description from the effect.
        /// </summary>
        /// <param name="emitterData"></param>
        public void RemoveEmitter(T2DParticleEmitterData emitterData)
        {
            // Remove emitter-data from list.
            _emitterDataList.Remove(emitterData);

            // Emitter List Changed.
            EmitterListChanged();
        }



        /// <summary>
        /// Clear out all emitter descriptions.
        /// </summary>
        public void ClearEmitterData()
        {
            // Clear emitter-data list.
            _emitterDataList.Clear();

            // Emitter List Changed.
            EmitterListChanged();
        }



        /// <summary>
        /// Test to see if effect data contains the given emitter data.
        /// </summary>
        /// <param name="emitterData">Emitter data to test.</param>
        /// <returns>True if emitter data is in the effect.</returns>
        public bool ContainsEmitterData(T2DParticleEmitterData emitterData)
        {
            return _emitterDataList.Contains(emitterData);
        }



        /// <summary>
        /// Return list of emitter data with the given name.
        /// </summary>
        /// <param name="name">Name to search for.</param>
        /// <returns>List of emitter data that match the name.</returns>
        public List<T2DParticleEmitterData> FindEmitterData(String name)
        {
            // Search for emitter name.
            return _emitterDataList.FindAll(delegate(T2DParticleEmitterData emitterData) { return emitterData.Name == name; });
        }



        /// <summary>
        /// Return indexed emitter data.  Use EmitterCount property to determine number of emitter data.
        /// </summary>
        /// <param name="index">Index of emitter.</param>
        /// <returns>Indexed emitter.</returns>
        public T2DParticleEmitterData FindEmitterData(int index)
        {
            // Sanity!
            Assert.Fatal(index < _emitterDataList.Count, "Cannot find emitter; index is out of bounds!");

            // Return Emitter.
            return _emitterDataList[index];
        }



        /// <summary>
        /// Change the order of an emitter in the list.  Returns new emitter index.
        /// </summary>
        /// <param name="emitterData">Emitter to move.</param>
        /// <param name="orderChange">Move operation.</param>
        /// <returns>New emitter index.</returns>
        public int MoveEmitterData(T2DParticleEmitterData emitterData, EmitterDataOrderChange orderChange)
        {
            // Sanity!
            Assert.Fatal(ContainsEmitterData(emitterData), "Cannot change emitter-data sequence; emitter not within effect!");

            // Find Emitter-Data Index.
            int emitterDataIndex = _emitterDataList.IndexOf(emitterData);

            // Sanity!
            Assert.Fatal(emitterDataIndex != -1, "Emitter-Data is not in the list; how can this happen?");

            // Handle emitter-data order change.
            switch (orderChange)
            {
                // FIRST in list.
                case EmitterDataOrderChange.First:
                    {
                        // Already first?
                        if (emitterDataIndex == 0)
                        {
                            // Yes, so finish!
                            return emitterDataIndex;
                        }

                        // Remove from emitter-data list.
                        _emitterDataList.Remove(emitterData);

                        // Insert emitter-data as FIRST.
                        _emitterDataList.Insert(0, emitterData);

                        // Emitter List Changed.
                        EmitterListChanged();

                        // Return new emitter-data index.
                        return 0;
                    };

                // LAST in list.
                case EmitterDataOrderChange.Last:
                    {
                        // Already last?
                        if (emitterDataIndex == _emitterDataList.Count - 1)
                        {
                            // Yes, so finish!
                            return emitterDataIndex;
                        }

                        // Remove from emitter-data list.
                        _emitterDataList.Remove(emitterData);

                        // Add emitter-data as LAST.
                        _emitterDataList.Add(emitterData);

                        // Emitter List Changed.
                        EmitterListChanged();

                        // Return new emitter-data index.
                        return emitterDataIndex;

                    };

                // NEXT in list.
                case EmitterDataOrderChange.Next:
                    {
                        // Already last?
                        if (emitterDataIndex == _emitterDataList.Count - 1)
                        {
                            // Yes, so finish!
                            return emitterDataIndex;
                        }

                        // Remove from emitter-data list.
                        _emitterDataList.Remove(emitterData);

                        // NEXT emitter-data index.
                        emitterDataIndex++;

                        // Insert as NEXT.
                        _emitterDataList.Insert(emitterDataIndex, emitterData);

                        // Emitter List Changed.
                        EmitterListChanged();

                        // Return new emitter-data index.
                        return emitterDataIndex;

                    };

                // PREVIOUS in list.
                case EmitterDataOrderChange.Previous:
                    {
                        // Already first?
                        if (emitterDataIndex == 0)
                        {
                            // Yes, so finish!
                            return emitterDataIndex;
                        }

                        // Remove from emitter-data list.
                        _emitterDataList.Remove(emitterData);

                        // PREVIOUS emitter-data index.
                        emitterDataIndex--;

                        // Insert as PREVIOUS.
                        _emitterDataList.Insert(emitterDataIndex, emitterData);

                        // Emitter List Changed.
                        EmitterListChanged();

                        // Return new emitter-data index.
                        return emitterDataIndex;

                    };
            }

            // No change so return emitter-data index.
            return emitterDataIndex;
        }

        #endregion


        #region Private, protected, internal methods

        // Emitter List Changed.
        internal void EmitterListChanged()
        {
            // Emitter List Changed Event.
            if (OnEmitterListChanged != null)
            {
                OnEmitterListChanged(this);
            }
        }

        #endregion


        #region Private, protected, internal fields

        // Effect Lifetime.
        private float _effectLifetime;

        // Effect Life Mode.
        private EffectLifeMode _effectlifeMode;

        // Graph Properties.
        private T2DKeyGraph_Scale _particleLife;
        private T2DKeyGraph_Scale _quantity;
        private T2DKeyGraph_Scale _sizeX;
        private T2DKeyGraph_Scale _sizeY;
        private T2DKeyGraph_Scale _speed;
        private T2DKeyGraph_Scale _spin;
        private T2DKeyGraph_Scale _fixedForce;
        private T2DKeyGraph_Scale _randomMotion;
        private T2DKeyGraph_Scale _visibility;
        private T2DKeyGraph_BaseVariation _emissionForce;
        private T2DKeyGraph_BaseVariation _emissionAngle;
        private T2DKeyGraph_BaseVariation _emissionArc;

        // Emitter-Data List.
        private List<T2DParticleEmitterData> _emitterDataList = new List<T2DParticleEmitterData>();

        #endregion

        #region IDisposable Members

        public override void Dispose()
        {
            _IsDisposed = true;
            ClearEmitterData();
            this.OnEmitterListChanged = null;
            this._ResetRefs();
            _emitterDataList = null;
            _particleLife = null;
            _quantity = null;
            _sizeX = null;
            _sizeY = null;
            _speed = null;
            _spin = null;
            _fixedForce = null;
            _randomMotion = null;
            _visibility = null;
            _emissionForce = null;
            _emissionAngle = null;
            _emissionArc = null;
            base.Dispose();
        }

        #endregion
    }



    /// <summary>
    /// A particle-effect encapsulates multiple particle-emitters.
    /// </summary>
    sealed public class T2DParticleEffect : T2DSceneObject, IAnimatedObject, IDisposable
    {
        #region Constructors

        public T2DParticleEffect()
        {
            // by default, we'll have physics and collision
            CreateWithPhysics = true;
        }

        #endregion


        #region Public properties, operators, constants, and enums

        #region Delegates

        // -------------------------------------------------------------
        // Delegates.
        // -------------------------------------------------------------
        public delegate void EffectStartEvent(T2DParticleEffect effect);
        public delegate void EffectStopEvent(T2DParticleEffect effect);
        public EffectStartEvent OnEffectStart;
        public EffectStopEvent OnEffectStop;

        #endregion //Delegates

        #region Non-T2DKeyGraph Properties

        // -------------------------------------------------------------
        // Non-Graph Properties.
        // -------------------------------------------------------------

        /// <summary>
        /// Age of effect, in seconds.  Compare to LifeTime property of T2DEffectData.
        /// </summary>
        public float Age
        {
            get
            {
                return _effectAge;
            }
            private set
            {
                // Sanity!
                Assert.Fatal(_effectAge >= 0.0f, "Effect Age must be >= 0.0!");

                // Set Effect Age.
                _effectAge = value;
            }
        }



        /// <summary>
        /// Specify whether the effect should begin playing automatically when it is registered.
        /// True by default.
        /// </summary>
        public bool PlayOnLoad
        {
            set { _playOnLoad = value; }
            get { return _playOnLoad; }
        }



        /// <summary>
        /// True if effect is currently playing.
        /// </summary>
        public bool EffectPlaying
        {
            get
            {
                return _effectPlaying;
            }
        }



        /// <summary>
        /// True if emitter is waiting for particles to go away.
        /// </summary>
        public bool WaitingForParticleClear
        {
            get
            {
                return _waitingForParticlesClear;
            }
        }



        // Emitter List.
        internal List<T2DParticleEmitter> EmitterList
        {
            get
            {
                return _emitterList;
            }
        }



        public override string AutoName
        {
            get
            {
                string autoname = base.AutoName;
                // add material name of first emitter
                if (_emitterList != null && _emitterList.Count > 0)
                {
                    if (_emitterList[0].CurrentEmitterData != null && _emitterList[0].CurrentEmitterData.Material != null)
                        autoname += "_" + _emitterList[0].CurrentEmitterData.Material.AutoName;
                }

                return autoname;
            }
        }

        #endregion //Non-T2DKeyGraph Properties

        #region Misc Properties

        // -------------------------------------------------------------
        // Misc.
        // -------------------------------------------------------------

        /// <summary>
        /// Matrix representing translation of this effect.
        /// </summary>
        public Matrix EffectTranslationMatrix
        {
            get
            {
                return _effectTranslationMatrix;
            }
        }



        /// <summary>
        /// Matrix representing translation and rotation of this effect.
        /// </summary>
        public Matrix EffectRotationTranslationMatrix
        {
            get
            {
                return _effectRotationTranslationMatrix;
            }
        }



        /// <summary>
        /// The T2DParticleEffectData which describes this effect.
        /// </summary>
        [TorqueCloneIgnore]
        public T2DParticleEffectData CurrentEffectData
        {
            get
            {
                return _effectData;
            }
            set
            {
                // Is Effect Playing?
                if (EffectPlaying)
                {
                    // Yes, so stop effect.
                    // NOTE:-   We've want to chang the effect-data so we need to
                    //          clear the particles immediately.
                    StopEffect(false);
                }

                // Already got effect-data?
                if (_effectData != null)
                {
                    // Yes, so unregister for emitter-list change.
                    _effectData.OnEmitterListChanged -= _OnEmitterListChanged;

                    // Clear Particle Emitters.
                    _emitterList.Clear();
                }

                // Set Effect Data.
                _effectData = value;

                // New effect-data?
                if (_effectData != null)
                {
                    // Yes, so register for emitter-list changes.
                    _effectData.OnEmitterListChanged += _OnEmitterListChanged;

                    // Fetch Emitter Data List.
                    List<T2DParticleEmitterData> emitterDataList = _effectData.EmitterDataList;

                    // Create Emitters.
                    foreach (T2DParticleEmitterData emitterData in emitterDataList)
                    {
                        _emitterList.Add(new T2DParticleEmitter(this, emitterData));
                    }
                }
            }
        }

        #endregion //Misc Properties

        #endregion


        #region Public methods

        public override void Reset()
        {
            base.Reset();

            StopEffect(false);

            // Sanity!
            Debug.Assert(!EffectPlaying, "Effect has been recycled but is still playing!");

            // prepare for next use by clearing out variables.
            _effectAge = 0.0f;
            _waitingForParticlesClear = false;
            _effectPlaying = false;
            //_peakParticleAllocations = 0; // its ok to not reset this.
            _currentParticleAllocations = 0;
        }



        /// <summary>
        /// Start generating particles, optionally clearing out old particles.
        /// </summary>
        /// <param name="clearParticles">If true, old particles will be removed.</param>
        public void PlayEffect(bool clearParticles)
        {
            // Sanity!
            Debug.Assert(MarkForDelete == false, "Cannot Play Effect; it's marked for deletion!");
            Debug.Assert(CurrentEffectData != null, "Cannot Play Effect; no effect data!");

            // Reset Effect Age.
            Age = 0.0f;
            // Enumerate Emitters.
            foreach (T2DParticleEmitter emitter in EmitterList)
            {
                // Play Emitter.
                emitter.PlayEmitter(clearParticles);
            }

            // Flag Not Waiting for Particle Clear.
            _waitingForParticlesClear = false;

            // Flag Effect Playing.
            _effectPlaying = true;

            // "OnEffectStart" Event.
            if (OnEffectStart != null)
            {
                OnEffectStart(this);
            }
        }



        /// <summary>
        /// Stop generating new particles, optionally waiting for existing particles to clear
        /// before calling OnEffectStop.
        /// </summary>
        /// <param name="waitForParticles">If true, will wait for particles to clear.</param>
        public void StopEffect(bool waitForParticles)
        {
            // Is Effect Playing?
            if (!EffectPlaying)
            {
                // No, so finish.
                return;
            }

            // Wait for particles?
            if (waitForParticles)
            {
                // Yes, so enumerate Emitters.
                foreach (T2DParticleEmitter emitter in EmitterList)
                {
                    // Pause Emitter.
                    emitter.PauseEmitter();
                }

                // Flag Waiting for Paricle Clear.
                _waitingForParticlesClear = true;

                // JMQ: added this for cyclic animations, it doesn't seem to get called otherwise.  
                // "OnEffectStop" Event.  
                if (OnEffectStop != null)
                {
                    OnEffectStop(this);
                }
            }
            else
            {
                // No, so enumerate Emitters.
                foreach (T2DParticleEmitter emitter in _emitterList)
                {
                    // Stop Emitter.
                    emitter.ClearParticles();
                }

                // Reset Effect Age.
                Age = 0.0f;

                // Flag Not Waiting for Particle Clear.
                _waitingForParticlesClear = false;

                // Flag Effect Stopped.
                _effectPlaying = false;

                // "OnEffectStop" Event.
                if (OnEffectStop != null)
                {
                    OnEffectStop(this);
                }
            }

            T2DLightComponent _lc = Components.FindComponent<T2DLightComponent>();
            if (_lc != null)
            {
                List<Light> _ll = _lc.LightList;
                IEnumerator _le = _ll.GetEnumerator();
                while (_le.MoveNext())
                {
                    SceneGraph.RemoveLight(_le.Current as Light);
                }
            }
        }



        public override bool OnRegister()
        {
            // Parent OnRegister.
            if (!base.OnRegister())
            {
                return false;
            }

            // Request Advance Time.
            ProcessList.Instance.AddAnimationCallback(this);

            // start playing the effect
            if (_playOnLoad)
                PlayEffect(false);

            // All Okay.
            return true;
        }



        public override void OnUnregister()
        {
            // Parent OnUnregister.
            base.OnUnregister();

            // since we are being removed we need to shutdown completely.
            StopEffect(false);
            ProcessList.Instance.RemoveObject(this);

            // Sanity!
            Debug.Assert(!EffectPlaying, "Effect has been recycled but is still playing!");

            // clear out variables in case we are recycled and used again.  Normally we would only need to do this in Reset, but right now
            // the engine doesn't call Reset on us, so we need to do it here.  Once the engine is calling Reset we can remove this code, but
            // it is still not a bad idea to clear things out here.
            _effectAge = 0.0f;
            _waitingForParticlesClear = false;
            _effectPlaying = false;
            //_peakParticleAllocations = 0; // its ok to not reset this.
            _currentParticleAllocations = 0;
            _effectData.OnEmitterListChanged -= _OnEmitterListChanged;
            this.OnEffectStart = null;
            this.OnEffectStop = null;
            //_effectData = null;
        }



        public void UpdateAnimation(float dt)
        {
            // Any effect-data?
            if (CurrentEffectData == null)
            {
                // No, so finish here.
                return;
            }

#if DEBUG
            Profiler.Instance.StartBlock("T2DParticleEffect.UpdateAnimation");
#endif

            // Calculate Temporary World-Space Transforms.
            // NOTE:-   These are used when generating particles during the integration phase so we calculate them
            //          once here so save lots of time later.
            _effectTranslationMatrix = Matrix.CreateTranslation(new Vector3(Position.X, Position.Y, LayerDepth));
            _effectRotationTranslationMatrix = Matrix.CreateRotationZ(MathHelper.ToRadians(Rotation)) * _effectTranslationMatrix;

            // Is the effect playing?
            if (_effectPlaying)
            {
                // Yes, so increase Effect Age.
                Age += dt;

                // Reset Particle Allocated Count.
                _currentParticleAllocations = 0;

                // Enumerate Emitters.
                foreach (T2DParticleEmitter emitter in EmitterList)
                {
                    // Advance Emitter Time.
                    emitter.AdvanceEmitterTime(dt);

                    // Track Emitter Allocations.
                    _currentParticleAllocations += emitter.Allocated;

                    // Sanity!
                    Assert.Fatal(_currentParticleAllocations < MaxParticleLimit, "Exceeded Particle-Engines' particle capacity limit!");
                }

                // Are we waiting for particles clear?
                if (!WaitingForParticleClear && Age >= CurrentEffectData.Lifetime)
                {
                    // No, so handle life modes...
                    switch (CurrentEffectData.LifeMode)
                    {
                        // NOTE:- We don't need to do anything for "Infinite" mode.
                        //case EffectLifeMode.Infinite:

                        // "Cycle" Mode.
                        case T2DParticleEffectData.EffectLifeMode.Cycle:
                            {
                                // Restart effect (don't clear any existing particles).
                                PlayEffect(false);

                            } break;

                        // "Stop" Mode.
                        case T2DParticleEffectData.EffectLifeMode.Stop:
                            {
                                // Stop Effect (wait for any existing particles).
                                StopEffect(true);

                            } break;

                        // "Kill" Mode.
                        case T2DParticleEffectData.EffectLifeMode.Kill:
                            {
                                // Stop Effect (wait for any existing particles).
                                StopEffect(true);

                            } break;
                    }
                }

                // Are we waiting for particles and we've no particle allocations?
                if (WaitingForParticleClear && _currentParticleAllocations == 0)
                {
                    // Yes, so stop effect immediately.
                    StopEffect(false);

                    // Are we in "Kill" mode?
                    if (CurrentEffectData.LifeMode == T2DParticleEffectData.EffectLifeMode.Kill)
                    {
                        // Yes, so mark for deletion.
                        MarkForDelete = true;
                    }
                }
            }

#if DEBUG
            Profiler.Instance.EndBlock("T2DParticleEffect.UpdateAnimation");
#endif
        }



        public override void Render(SceneRenderState srs)
        {
#if DEBUG
            Profiler.Instance.StartBlock("T2DParticleEffect.Render");
#endif

            // Any effect-data?
            if (CurrentEffectData == null)
            {
                // No, so finish here.
#if DEBUG
                Profiler.Instance.EndBlock("T2DParticleEffect.Render");
#endif
                return;
            }

            // Any particle allocations?
            if (_currentParticleAllocations == 0)
            {
                // No, so finish here.
#if DEBUG
                Profiler.Instance.EndBlock("T2DParticleEffect.Render");
#endif
                return;
            }

            // Update Render Batch.
            _UpdateRenderBatch();

            // Fetch Graphics Device.
            GraphicsDevice d3d = srs.Gfx.Device;
            // Sanity!
            Assert.Fatal(d3d != null, "Could not acquire graphics device!");

            // MM: This'll do for now!
            _tangent = new Vector4(MatrixUtil.MatrixGetRow(0, ref srs._camTrans), 1.0f);
            _normal = new Vector4(MatrixUtil.MatrixGetRow(2, ref srs._camTrans), 0.0f);

            // Calculate Vertex Count.
            int vertexCount = _currentParticleAllocations * 4;

            // Create Scratch Vertex Array.
            GFXVertexFormat.PCTTBN[] _vertexScratch = TorqueUtil.GetScratchArray<GFXVertexFormat.PCTTBN>(vertexCount);

            // Sanity!
            Assert.Fatal(_vertexScratch != null, "Invalid vertex scratch!");

            int vertexOffset = 0;

            // Enumerate Emitters.
            foreach (T2DParticleEmitter emitter in _emitterList)
            {
                // Is emitter showing and has some particles allocated?
                if (!emitter.CurrentEmitterData.Hidden && emitter.Allocated > 0)
                {
                    _textureCoords = emitter.CurrentEmitterData.TextureCoords;

                    // Create Render Instance.
                    RenderInstance ri = SceneRenderer.RenderManager.AllocateInstance();
                    ri.Type = RenderInstance.RenderInstanceType.Mesh2D;

                    // Sanity!
                    Assert.Fatal(_vertexScratch != null, "Invalid vertex scratch!");

                    // Populate Render Instance.
                    ri.ObjectTransform = emitter.ParticleRenderTransform;
                    ri.VertexBuffer = _vertexBuffer.Instance;
                    ri.IndexBuffer = _indexBuffer.Instance;
                    ri.BaseVertex = vertexOffset;
                    ri.StartIndex = 0;
                    ri.PrimitiveType = PrimitiveType.TriangleList;
                    ri.PrimitiveCount = emitter.Allocated * 2;
                    ri.VertexCount = emitter.Allocated * 4;
                    ri.VertexSize = GFXVertexFormat.VertexSize;
                    ri.VertexDeclaration = GFXVertexFormat.GetVertexDeclaration(GFXDevice.Instance.Device);
                    ri.Opacity = VisibilityLevel;
                    ri.UTextureAddressMode = TextureAddressMode.Clamp;
                    ri.VTextureAddressMode = TextureAddressMode.Clamp;
                    ri.Material = emitter.CurrentEmitterData.Material;

                    // Render Emitter.
                    emitter.RenderEmitter(_vertexScratch,
                                            ref vertexOffset,
                                            _textureCoords,
                                            ref _normal,
                                            ref _tangent);

                    // Add Render Instance to Render Manager.
                    SceneRenderer.RenderManager.AddInstance(ri);
                }
            }

            // Sanity!
            Assert.Fatal(vertexOffset <= vertexCount, "Vertex Count Mismatch rendering effect!");

            // NOTE:-   It's important to note that the vertex offsets may not realize the vertex
            //          counts as emitters can be hidden and therefore won't contribute to the offset 
            //          into the vertex buffers.
            //
            // JMQ: except that if you pass a zero vertexOffset into the SetData function, it
            // will throw an exception.  Added a check for that.
            //
            if (vertexCount != 0 && vertexOffset > 0)
            {
                GFXDevice.Instance.Device.Vertices[0].SetSource(null, 0, 0);
#if XBOX
                   _vertexBuffer.Instance.SetData<GFXVertexFormat.PCTTBN>(_vertexScratch, 0, vertexOffset);
#else
                _vertexBuffer.Instance.SetData<GFXVertexFormat.PCTTBN>(_vertexScratch, 0, vertexOffset, SetDataOptions.Discard);
#endif
            }

            _vertexScratch = null;

            // Base Render.
            base.Render(srs);

#if DEBUG
            Profiler.Instance.EndBlock("T2DParticleEffect.Render");
#endif
        }



        public override void CopyTo(TorqueObject obj)
        {
            base.CopyTo(obj);
            T2DParticleEffect obj2 = (T2DParticleEffect)(obj);

            // Create an actual clone of the emitters to allow runtime
            // changes to each single copy without affecting the others.

            obj2.CurrentEffectData = null;
            T2DParticleEffectData _ed = new T2DParticleEffectData();
            _ed.LifeMode = this.CurrentEffectData.LifeMode;
            _ed.Lifetime = this.CurrentEffectData.Lifetime;

            // Fetch Emitter Data List.
            foreach (T2DParticleEmitterData _p in this.CurrentEffectData.EmitterDataList)
            {
                T2DParticleEmitterData _t = new T2DParticleEmitterData(_p.Name);
                _t.AttachPositionToEmitter = _p.AttachPositionToEmitter;
                _t.AttachRotationToEmitter = _p.AttachRotationToEmitter;
                _t.BlueChannelLife = _p.BlueChannelLife;
                _t.EmissionAngleBase = _p.EmissionAngleBase;
                _t.EmissionAngleVariation = _p.EmissionAngleVariation;
                _t.EmissionArcBase = _p.EmissionArcBase;
                _t.EmissionArcVariation = _p.EmissionArcVariation;
                _t.EmissionForceBase = _p.EmissionForceBase;
                _t.EmissionForceVariation = _p.EmissionForceVariation;
                _t.EmitterArea = _p.EmitterArea;
                _t.FirstInFrontOrder = _p.FirstInFrontOrder;
                _t.FixedAreaAspect = _p.FixedAreaAspect;
                _t.FixedForceAngle = _p.FixedForceAngle;
                _t.FixedForceBase = _p.FixedForceBase;
                _t.FixedForceLife = _p.FixedForceLife;
                _t.FixedForceVariation = _p.FixedForceVariation;
                _t.FixedParticleAspect = _p.FixedParticleAspect;
                _t.GreenChannelLife = _p.GreenChannelLife;
                _t.Hidden = _p.Hidden;
                _t.InitialAge = _p.InitialAge;
                _t.LinkEmissionRotation = _p.LinkEmissionRotation;
                _t.Material = _p.Material;
                _t.MaterialRegionIndex = _p.MaterialRegionIndex;
                _t.OrientationAngleOffset = _p.OrientationAngleOffset;
                _t.OrientationRandomArc = _p.OrientationRandomArc;
                _t.ParticleLifeBase = _p.ParticleLifeBase;
                _t.ParticleLifeVariation = _p.ParticleLifeVariation;
                _t.ParticleOrientation = _p.ParticleOrientation;
                _t.ParticlePivotPoint = _p.ParticlePivotPoint;
                _t.QuantityBase = _p.QuantityBase;
                _t.QuantityVariation = _p.QuantityVariation;
                _t.RandomMotionBase = _p.RandomMotionBase;
                _t.RandomMotionLife = _p.RandomMotionLife;
                _t.RandomMotionVariation = _p.RandomMotionVariation;
                _t.RedChannelLife = _p.RedChannelLife;
                _t.SingleParticle = _p.SingleParticle;
                _t.SizeXBase = _p.SizeXBase;
                _t.SizeXLife = _p.SizeXLife;
                _t.SizeXVariation = _p.SizeXVariation;
                _t.SizeYBase = _p.SizeYBase;
                _t.SizeYLife = _p.SizeYLife;
                _t.SizeYVariation = _p.SizeYVariation;
                _t.SpeedBase = _p.SpeedBase;
                _t.SpeedLife = _p.SpeedLife;
                _t.SpeedVariation = _p.SpeedVariation;
                _t.SpinBase = _p.SpinBase;
                _t.SpinLife = _p.SpinLife;
                _t.SpinVariation = _p.SpinVariation;
                _t.TextureCoords = _p.TextureCoords;
                _t.UseEffectEmission = _p.UseEffectEmission;
                _t.VisibilityLife = _p.VisibilityLife;
                _ed.EmitterDataList.Add(_t);
            }

            obj2.CurrentEffectData = _ed;
            obj2._playOnLoad = _playOnLoad;
        }



        public void UpdateVertexBuffer()
        {
            foreach (T2DParticleEmitter emitter in _emitterList)
                emitter.CurrentEmitterData.TextureCoords = null;
        }


        #endregion


        #region Private, protected, internal methods

        // Update Render Batch.
        private void _UpdateRenderBatch()
        {
            // Sanity!
            Assert.Fatal(_currentParticleAllocations < MaxParticleLimit, "Exceeded Particle-Engines' particle capacity limit!");

            // Have we exceeded our previous peak particle capacity?
            if (_currentParticleAllocations <= _peakParticleAllocations &&
                    !_vertexBuffer.IsNull &&
                    !_indexBuffer.IsNull)
                return;

            // Only increase peak allocation if we've exceeded the peak!
            // NOTE:-   This stops us increasing the capacity if we've simply got invalid buffers!
            if (_currentParticleAllocations > _peakParticleAllocations)
            {
                // Yes, so calculate new  peak capacity.
                _peakParticleAllocations = _currentParticleAllocations + T2DParticleManager.Instance.ChunkSize;
            }

            // Calculate Vertex Count.
            int vertexCount = _peakParticleAllocations * 4;

            // Calculate Index Count.
            int indexCount = _peakParticleAllocations * 6;

            // Create Vertex Buffer.
            if (!_vertexBuffer.IsNull)
            {
                _vertexBuffer.Instance.Dispose();
                _vertexBuffer.Invalidate();
            }
            _vertexBuffer = ResourceManager.Instance.CreateDynamicVertexBuffer(ResourceProfiles.ManualStaticVBProfile, vertexCount * GFXVertexFormat.VertexSize);

            // Create Index Buffer.
            if (!_indexBuffer.IsNull)
            {
                _indexBuffer.Instance.Dispose();
                _indexBuffer.Invalidate();
            }
            _indexBuffer = ResourceManager.Instance.CreateIndexBuffer(ResourceProfiles.ManualStaticIBProfile, indexCount * sizeof(short), IndexElementSize.SixteenBits);

            // Setup the static index buffer for rendering particles here once
            // as the index pattern doesn't change.
            short[] indexScratch = TorqueUtil.GetScratchArray<short>(indexCount);
            Assert.Fatal(indexScratch != null, "Invalid index scratch!");
            int indexOffset = 0;
            for (int n = 0; n < _peakParticleAllocations; n++)
            {
                int basePrimitive = n * 4;
                indexScratch[indexOffset++] = (short)(basePrimitive);
                indexScratch[indexOffset++] = (short)(basePrimitive + 1);
                indexScratch[indexOffset++] = (short)(basePrimitive + 2);
                indexScratch[indexOffset++] = (short)(basePrimitive);
                indexScratch[indexOffset++] = (short)(basePrimitive + 2);
                indexScratch[indexOffset++] = (short)(basePrimitive + 3);
            }
            _indexBuffer.Instance.SetData<short>(indexScratch, 0, indexCount);
        }



        // Emitter-List has changed!
        private void _OnEmitterListChanged(T2DParticleEffectData effectData)
        {
            // Sanity!
            Debug.Assert(effectData == CurrentEffectData, "Notified of effect-data change but not current assigned to effect!");

            // For now, this'll stop the effect and recreate the emitters!
            // NOTE:-   The intention is to actively update the emitter-order
            //          in realtime so that we can tweak this kind of thing
            //          in an editor.
            CurrentEffectData = effectData;
        }

        #endregion


        #region Private, protected, internal fields

        // Effect Data.
        private T2DParticleEffectData _effectData;

        // Emitter List.
        private List<T2DParticleEmitter> _emitterList = new List<T2DParticleEmitter>();

        // Effect Lifetime.
        private float _effectAge;
        private bool _waitingForParticlesClear = false;
        private bool _effectPlaying = false;
        private bool _playOnLoad = true;

        // Pre-Calculated Transformations.
        private Matrix _effectTranslationMatrix = Matrix.Identity;
        private Matrix _effectRotationTranslationMatrix = Matrix.Identity;

        // Render Batching.
        private Resource<DynamicVertexBuffer> _vertexBuffer;
        private Resource<IndexBuffer> _indexBuffer;
        private static Vector4 _normal;
        private static Vector4 _tangent;
        private int _peakParticleAllocations = 0;
        private int _currentParticleAllocations = 0;
        private const int MaxParticleLimit = 18000;
        private Vector2[] _textureCoords = new Vector2[4];


        #endregion

        #region IDisposable Members

        public override void Dispose()
        {
            _IsDisposed = true;
            if (!_vertexBuffer.IsNull)
            {
                _vertexBuffer.Instance.Dispose();
                _vertexBuffer.Invalidate();
            }

            if (!_indexBuffer.IsNull)
            {
                _indexBuffer.Instance.Dispose();
                _indexBuffer.Invalidate();
            }

            if (_effectData != null)
            {
                //_effectData.ClearEmitterData();
                _effectData.OnEmitterListChanged -= _OnEmitterListChanged;
            }
            _effectData = null;

            if (_emitterList != null)
            {
                for (int i = _emitterList.Count - 1; i >= 0; i--)
                    _emitterList[i] = null;
                _emitterList = null;
            }
            this.OnEffectStart = null;
            this.OnEffectStop = null;
            this.OnRegistered = null;
            base.Dispose();
        }

        #endregion
    }
}

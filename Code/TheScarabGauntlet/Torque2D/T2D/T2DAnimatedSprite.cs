//-----------------------------------------------------------------------------
// Torque X Game Engine
// Copyright © GarageGames.com, Inc.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using GarageGames.Torque.Core;
using GarageGames.Torque.Util;
using GarageGames.Torque.Materials;
using GarageGames.Torque.MathUtil;
using GarageGames.Torque.SceneGraph;
using GarageGames.Torque.GFX;
using GarageGames.Torque.RenderManager;
using GarageGames.Torque.Sim;



namespace GarageGames.Torque.T2D
{
    /// <summary>
    /// Delegate to specify events when frames changes, passes along the index of the last frame.
    /// </summary>
    /// <param name="frame">index of the previous frame</param>
    public delegate void OnFrameChangeDelegate(int frame);



    /// <summary>
    /// Delegate to specify an event when the animation has ended.
    /// </summary>
    public delegate void OnAnimationEndDelegate();



    /// <summary>
    /// Animation data used in animated sprites.
    /// Consists of a material and animation frames definition properties.
    /// </summary>
    public class T2DAnimationData : TorqueObject, IDisposable
    {
        #region Public properties, operators, constants, and enums

        /// <summary>
        /// Total duration of the animation.
        /// This is the total time it takes to integrate through all the frames of the animation
        /// </summary>
        public float AnimationDuration
        {
            set { _animationDuration = value; }
            get { return _animationDuration; }
        }



        /// <summary>
        /// Determines whether the animation will cycle, or repeat once it has finished.
        /// Set it to true to cycle, false if you want to animation to stop once it has finished.
        /// </summary>
        public bool AnimationCycle
        {
            set { _animationCycle = value; }
            get { return _animationCycle; }
        }



        /// <summary>
        /// Material or texture used by the animation data
        /// </summary>
        public RenderMaterial Material
        {
            get { return _material; }
            set { _material = value; _isInitialized = false; }
        }



        /// <summary>
        /// List of texture coordinates generated by the initialized animation data
        /// </summary>
        public List<RectangleF> AnimationFramesList
        {
            get
            {
                if (!_isInitialized)
                    Init();

                return _animationFramesList;
            }
        }



        /// <summary>
        /// String representing the frames to be used in the animation.
        /// Seperated by spaces, frames begin at 0 and can be repeated.
        /// </summary>
        public String AnimationFrames
        {
            get { return _animationFrames; }
            set { _animationFrames = value; _isInitialized = false; }
        }



        /// <summary>
        /// Has the AnimationData been initialized yet?
        /// </summary>
        public Boolean IsInitialized
        {
            get { return _isInitialized; }
        }



        #endregion


        #region Public methods

        public override bool OnRegister()
        {
            if (!base.OnRegister())
                return false;

            if (!_isInitialized)
                Init();

            return true;
        }



        /// <summary>
        /// Once the data properties and texture has been loaded - initialize the animation data.
        /// </summary>
        public override void OnLoaded()
        {
            base.OnLoaded();

            if (!_isInitialized)
                Init();
        }



        /// <summary>
        /// Generates the list of frames to be used in the animation based on available frames and the AnimationFrames property
        /// Each frame specifies the texture coordinates for that particular frame from the specified texture.
        /// This is a public function in the event that an animation recieves data that has not been initialized yet.
        /// </summary>
        public void Init()
        {
            // no material, skip initialization
            if (_material == null)
            {
                Assert.Fatal(_isInitialized, "T2DAnimationData.Init() - Animation data failed to initialize due to null material. Animation name: " + Name);
                return;
            }

            // create a new list to store the texture coordinates of the different frames of the animation
            _animationFramesList = new List<RectangleF>();
            int imageMapFrameCount = _material.TextureRegionCount;

            // make sure there is at least one region on te material
            Assert.Fatal(imageMapFrameCount > 0, "no animation frames to generate an animation from");

            // any frames specified?
            if (_animationFrames != null)
            {
                // if so then generate an animation based on the frames
                string[] frames = _animationFrames.Split(' ');  // frames to be used in the final animation

                // make sure there is at least one frame
                Assert.Fatal(frames.Length > 0, "no frame numbers retrieved from animation frame list");

                // create a new array to store the frame indeces
                _framesList = new int[frames.Length];

                // populate the frame index list
                for (int i = 0; i < frames.Length; i++)
                    _framesList[i] = Convert.ToInt16(frames[i]);

                // make sure we got at least one frame
                Assert.Fatal(_framesList.Length > 0, "no frames retrieved for the frames list");

                if (_framesList.Length > 0)
                {
                    // finally generate the animation list
                    int frameIndex;
                    for (int j = 0; j < _framesList.Length; j++)
                    {
                        frameIndex = _framesList[j];
                        if (frameIndex < imageMapFrameCount)
                            _animationFramesList.Add(_material.GetRegionCoords(frameIndex));
                    }
                }
            }
            else
            {
                // otherwise generate the animation using all the frames in the image
                for (int i = 0; i < imageMapFrameCount; i++)
                    _animationFramesList.Add(_material.GetRegionCoords(i));
            }

            // do we have an animation frames list?
            Assert.Fatal(_animationFramesList.Count > 0, "doh! failed to create an animation");

            _isInitialized = true;
        }



        public override void CopyTo(TorqueObject obj)
        {
            base.CopyTo(obj);
            T2DAnimationData obj2 = (T2DAnimationData)obj;
            obj2.AnimationDuration = AnimationDuration;
            obj2.AnimationCycle = AnimationCycle;
            obj2.Material = Material;
            obj2.AnimationFrames = AnimationFrames;
        }

        #endregion


        #region Private, protected, internal fields

        private RenderMaterial _material;

        private string _animationFrames;
        private int[] _framesList; // list of frames to be used in the animation
        private List<RectangleF> _animationFramesList; // ordered list of frames that make up the animation

        private bool _isInitialized;

        private float _animationDuration;
        private bool _animationCycle;
        #endregion

        #region IDisposable Members

        public override void Dispose()
        {
            _IsDisposed = true;
            _material = null;
            _animationFrames = null;
            if (_animationFramesList != null)
                _animationFramesList.Clear();
            _animationFramesList = null;
            base.Dispose();
        }

        #endregion
    }



    /// <summary>
    /// This is a data type designed to enable auto-restoring interrupted animations, but it could potentially be used
    /// to start any animation at a specific time.
    /// </summary>
    public class T2DAnimationCue
    {

        #region Constructors

        public T2DAnimationCue(T2DAnimationData animationData, float cueTime)
        {
            _animationData = animationData;
            _restoreTime = cueTime;
        }

        #endregion


        #region Public properties, operators, constants, and enums

        /// <summary>
        /// The animation data associated with this animation cue.
        /// </summary>
        public T2DAnimationData AnimationData
        {
            get { return _animationData; }
        }



        /// <summary>
        /// The time in seconds that this animation cue is set to load the specified animation data.
        /// </summary>
        public float RestoreTime
        {
            get { return _restoreTime; }
        }

        #endregion


        #region Private, protected, internal fields

        private float _restoreTime;
        private T2DAnimationData _animationData;

        #endregion
    }



    /// <summary>
    /// Animated Sprite Class.  
    /// </summary>
    public class T2DAnimatedSprite : T2DSceneObject, IAnimatedObject, IDisposable
    {

        #region Constructors

        public T2DAnimatedSprite()
        {
            // by default, we'll have physics and collision
            CreateWithCollision = true;
            CreateWithPhysics = true;
        }



        public T2DAnimatedSprite(T2DAnimationData _data)
            : this()
        {
            // record the specified animation data
            AnimationData = _data;
        }

        #endregion


        #region Public properties, operators, constants, and enums

        /// <summary>
        /// T2DAnimationData to be used in the animation
        /// </summary>
        public T2DAnimationData AnimationData
        {
            get { return _animationData; }
            set
            {
                // skip extra processing for duplicate assignments
                if (_animationData == value)
                    return;

                // record the new animation data
                _animationData = value;

                // make sure the animation data is initialized
                if (!_animationData.IsInitialized)
                    _animationData.Init();

                // set the animation data dirty flag so the sprite knows to update its texture coordinates and
                // material aswell as the animation controller's frame count, duration, and cycle properties
                _animationDataDirty = true;
            }
        }



        /// <summary>
        /// Specifies the start frame of the animation data to begin the animation
        /// </summary>
        public int StartFrame
        {
            set { _ac.StartFrame = value; }
            get { return _ac.StartFrame; }

        }



        /// <summary>
        /// Returns the total animation duration.
        /// This time is divided up amoungst the frames. If there are more frames in the animation the time
        /// spent on each frame will be less. This should be defined in the animation data.
        /// </summary>
        public float AnimationDuration
        {
            get { return _ac.AnimationDuration; }
        }



        /// <summary>
        /// Scales the animation speed.
        /// </summary>
        public float AnimationTimeScale
        {
            set { _ac.AnimationTimeScale = value; }
            get { return _ac.AnimationTimeScale; }

        }



        /// <summary>
        /// Returns whether the animated sprite is set to cycle or not.
        /// This should be defined in the animation data.
        /// </summary>
        public bool AnimationCycle
        {
            get { return _ac.AnimationCycle; }
        }



        /// <summary>
        /// Specifies to choose a random starting frame.
        /// </summary>
        public bool RandomStart
        {
            get { return _ac.RandomStart; }
            set { _ac.RandomStart = value; }
        }



        /// <summary>
        /// Returns the current animation frame index
        /// </summary>
        public int CurrentFrame
        {
            get { return _ac.CurrentFrame; }
        }



        /// <summary>
        /// Returns the final frame index
        /// </summary>
        public int FinalFrame
        {
            get { return _ac.FinalFrame; }
        }



        /// <summary>
        /// Returns the current animation time
        /// </summary>
        public float CurrentTime
        {
            get { return _ac.CurrentTime; }
            set { _ac.CurrentTime = value; }
        }



        /// <summary>
        /// Specifies whether or not the animation is both playing and not yet finished.
        /// </summary> 
        public bool IsAnimationPlaying
        {
            get { return !_ac.AnimationFinished && !_isPaused; }
        }



        /// <summary>
        /// Specify whether the animation should begin playing automatically when it is registered.
        /// True by default.
        /// </summary>
        public bool PlayOnLoad
        {
            set { _playOnLoad = value; }
            get { return _playOnLoad; }
        }



        /// <summary>
        /// Specifies whether the animation should be unregistered once it is finished.
        /// </summary>
        public bool RemoveOnFinished
        {
            get { return _removeOnFinished; }
            set { _removeOnFinished = value; }
        }



        /// <summary>
        /// Pauses or unpauses the animation.
        /// </summary>
        public bool AnimationPaused
        {
            get { return _isPaused; }
            set { _isPaused = value; }
        }



        /// <summary>
        /// Returns or sets the pause duration of the animation.
        /// </summary>
        public float AnimationPauseTime
        {
            get { return _pauseTime; }
            set { _pauseTime = value; }
        }



        public override string AutoName
        {
            get
            {
                string autoname = base.AutoName;
                // add material name
                if (AnimationData != null && AnimationData.Material != null)
                    autoname += "_" + AnimationData.Material.AutoName;

                return autoname;
            }
        }



        /// <summary>
        /// Delegate to be called when a frame changes.
        /// </summary>
        [XmlIgnore]
        public OnFrameChangeDelegate OnFrameChange
        {
            get { return _onFrameChange; }
            set { _onFrameChange = value; }
        }



        /// <summary>
        /// Delegate to be called when the animation ends.
        /// </summary>
        [XmlIgnore]
        public OnAnimationEndDelegate OnAnimationEnd
        {
            get { return _onAnimationEnd; }
            set { _onAnimationEnd = value; }
        }

        #endregion


        #region Public methods

        public override bool OnRegister()
        {
            if (!base.OnRegister())
                return false;

            // initialize the current animation
            _InitAnimation();

            // if _playOnLoad is true, play the animation now
            if (_playOnLoad)
                _isPaused = false;
            else
                _isPaused = true;

            ProcessList.Instance.AddAnimationCallback(this);

            return true;
        }

        public override void OnUnregister()
        {
            ProcessList.Instance.RemoveObject(this);
            base.OnUnregister();
        }

        /// <summary>
        /// Passes the animation data to the animation controller and begins the animation
        /// </summary>
        public void PlayAnimation()
        {
            // make sure we have an animation specified
            Assert.Fatal(_animationData != null, "doh! No animation data specified.");

            // initialize the animation
            _InitAnimation();

            // make sure that the animation will play
            _isPaused = false;
        }



        /// <summary>
        /// Plays an animation with specified animation data.
        /// </summary>
        /// <param name="data">animation data</param>
        public void PlayAnimation(T2DAnimationData data)
        {
            // replace the current animation data with the one specified
            AnimationData = data;

            // begin the new animation
            PlayAnimation();
        }



        /// <summary>
        /// Plays the specified animation data. When that animation is completed, the animation currently playing (at the time you call this method)
        /// will be loaded and resume from the time specified.
        /// </summary>
        /// <param name="data">The animation to play</param>
        /// <param name="autoRestoreTime">The time in seconds from which to continue playing the current animation.</param>
        public void PlayAnimation(T2DAnimationData data, float autoRestoreTime)
        {
            // create and push a new animation cue to the front of the queue
            _animationQueue.Insert(0, new T2DAnimationCue(_animationData, autoRestoreTime));

            // play the specified animation
            PlayAnimation(data);
        }



        /// <summary>
        /// Plays an animation with specified animation data and either queue up the currently playing animation to continue after 
        /// the specified animation is finished -or- clears all queued animations and does not auto-restore. If you do not wish to auto 
        /// restore the currently playing animation, but want to keep the animation queue intact, use the PlayAnimation(T2DAnimationData data) 
        /// version of this method.
        /// </summary>
        /// <param name="data">The animation data to use.</param>
        /// <param name="autoRestoreAnimation">True if the animated sprite should return to it's current animation once the specified animation 
        /// is finished. False if the animation should not auto restore and the entire animation queue should be cleared.</param>
        public void PlayAnimation(T2DAnimationData data, bool autoRestoreAnimation)
        {
            // either insert the current animation at the beginning of the the animation queue
            // or clear the animation queue entirely
            if (autoRestoreAnimation)
                _animationQueue.Insert(0, GenerateAnimationCue());
            else
                _animationQueue.Clear();

            // replace the current animation data with the one specified
            PlayAnimation(data);
        }



        /// <summary>
        /// Pauses the current animation.
        /// </summary>
        public void PauseAnimation()
        {
            // turn _isPaused on
            _isPaused = true;
        }



        /// <summary>
        /// Pauses the current animation for a set time.
        /// </summary>
        public void PauseAnimation(float time)
        {
            // turn _isPaused on
            _isPaused = true;
            _pauseTime = time;
        }



        /// <summary>
        /// Resumes the current paused animation.
        /// </summary>
        public void ResumeAnimation()
        {
            // turn pause off
            _isPaused = false;

            // set AnimationFinished to false on the animation controller. this should cause a second 
            // OnAnimationFinished call if the animation was finished, but that seems correct.
            _ac.AnimationFinished = false;
        }



        /// <summary>
        /// Sets the current frame of the animation.
        /// </summary>
        /// <param name="index">The frame of the animation to skip to.</param>
        /// <returns>True if the specified animation frame was successfully set.</returns>
        public bool SetAnimationFrame(uint index)
        {
            // tell our animation controller to set its frame explicitly
            return _ac.SetAnimationFrame(index);
        }



        /// <summary>
        /// Advances the frame of the animation by one frame. If the AnimationCycle is true and the animation is on its last frame, this
        /// will properly reset the animation to it's first frame.
        /// </summary>
        /// <returns>True if the animation frame was successfully advanced.</returns>
        public bool AdvanceFrame()
        {
            // if we don't know where to start from, do nothing
            if (StartFrame == -1)
                return false;

            // set our index ahead one frame
            uint nextFrame = (uint)CurrentFrame + 1;

            // if our index exceeds the number of frames, check for cycling
            if (nextFrame >= _ac.AnimationFrameCount)
            {
                if (AnimationCycle == false)
                    return false;

                // cycle back to the beginning
                nextFrame = (uint)StartFrame;
            }

            // call into our animation controller to actually set the frame
            return _ac.SetAnimationFrame(nextFrame);
        }



        /// <summary>
        /// Clears all previously queued animation cues from the list. Call this to guarantee that when the current animation 
        /// is finished no other animations will be loaded.
        /// </summary>
        public void ClearAnimationQueue()
        {
            // ... clear the animation queue!
            _animationQueue.Clear();
        }



        /// <summary>
        /// Generates an animaton cue object for the current animation data and time settings. This can be used to restore
        /// the animation to it's current state later on.
        /// </summary>
        /// <returns>A T2DAnimationCue object representing the current state of the animated sprite's current animation.</returns>
        public T2DAnimationCue GenerateAnimationCue()
        {
            // create and return a new restore info based on the current animation/time
            return new T2DAnimationCue(AnimationData, CurrentTime);
        }



        /// <summary>
        /// Attempts to load the specified animation cue. 
        /// </summary>
        /// <param name="animCue">The T2DAnimationCue to try to load.</param>
        /// <returns>True if the load was successful.</returns>
        public bool LoadAnimationCue(T2DAnimationCue animCue)
        {
            // make sure the restore info isn't bunk
            if (!_ValidateAnimationCue(animCue))
                return false;

            // accept the values from the restore info
            AnimationData = animCue.AnimationData;
            CurrentTime = animCue.RestoreTime;

            // tell the animation controller we're not finished!
            _ac.AnimationFinished = false;

            // make sure the animation is updated so we start at the right time and get the
            // right texture coordinates next render for whatever frame the animation's on
            // (note that _InterpretAnimationData is explicitly called here before 
            // UpdateAnimation)
            _InterpretAnimationData();
            _ac.UpdateAnimation();

            // success
            return true;
        }



        /// <summary>
        /// Finds and loads the next valid animation cue in the animation queue.
        /// </summary>
        /// <returns>True if the cue was successfully retrieved and loaded.</returns>
        public bool LoadNextCueInQueue()
        {
            bool success = false;
            T2DAnimationCue animCue = null;

            // loop through all animation cues until we find a valid one
            while (_animationQueue.Count > 0 && !success)
            {
                // retrieve and remove the first cue in the queue
                animCue = _animationQueue[0];
                _animationQueue.RemoveAt(0);

                // attempt to validate it
                success = _ValidateAnimationCue(animCue);
            }

            // if we found a cue, try to load it
            if (success)
                return LoadAnimationCue(animCue);

            // couldn't find a cue (got to the end of the list)
            // make sure the list is truly empty and return false
            _animationQueue.Clear();

            return false;
        }



        /// <summary>
        /// Generates and adds an animation cue to the animation queue to be played after all animations are finished.
        /// </summary>
        /// <param name="animData">The animation data to add to the animation queue.</param>
        public void EnqueueAnimation(T2DAnimationData animData)
        {
            // creates an animation cue for the specified animation data
            // at time 0 and adds it to the queue
            _animationQueue.Add(new T2DAnimationCue(animData, 0.0f));
        }



        /// <summary>
        /// Adds an animation cue to the animation queue to be played after all animations are finished.
        /// </summary>
        /// <param name="animCue">The animation cue to add to the animation queue.</param>
        public void EnqueueAnimation(T2DAnimationCue animCue)
        {
            // add the animation cue to the end of the list
            _animationQueue.Add(animCue);
        }



#if DEBUG
        static ProfilerCodeBlock Profiler_UpdateAnimation = new ProfilerCodeBlock("T2DAnimatedSprite.UpdateAnimation");
#endif



        public virtual void UpdateAnimation(float dt)
        {
            Assert.Fatal(IsRegistered, "doh?");

#if DEBUG
            Profiler.Instance.StartBlock(Profiler_UpdateAnimation);
#endif

            // if the animation controller has not been initialized, quit now
            if (!_ac.IsInitialized || _animationData == null)
            {
#if DEBUG
                Profiler.Instance.EndBlock(Profiler_UpdateAnimation);
#endif

                return;
            }

            // interpret animation data if dirty
            if (_animationDataDirty)
                _InterpretAnimationData();

            // delete the object if remove on finished is set and the animation is done
            if (!_ac.AnimationCycle && _ac.AnimationFinished && RemoveOnFinished)
            {
                MarkForDelete = true;

#if DEBUG
                Profiler.Instance.EndBlock(Profiler_UpdateAnimation);
#endif
                return;
            }

            // if the animation is not finished, update it
            if (!_ac.AnimationFinished || _ac.AnimationCycle)
            {
                if (_isPaused && _pauseTime != 0.0f)
                {
                    _pauseTime -= dt;
                    if (_pauseTime <= 0.0f)
                    {
                        _pauseTime = 0.0f;
                        _isPaused = false;
                    }
                }

                // if the animation is paused, don't advance it
                if (_isPaused)
                {
#if DEBUG
                    Profiler.Instance.EndBlock(Profiler_UpdateAnimation);
#endif
                    return;
                }

                // advance the animation
                _frameChanged = _ac.AdvanceAnimation(dt);

                // check if the frame changed
                if (_frameChanged)
                {
                    // set the frame area dirt flag to true
                    _currentFrameAreaDirty = true;

                    // call the OnFrameChange delegate, if we have one
                    if (this.OnFrameChange != null)
                        this.OnFrameChange(CurrentFrame);
                }

                // check if the latest update brought us to the end of the animation
                if (_ac.AnimationFinished)
                {
                    // if we have any animation cues queued up play 
                    // the last one in the list
                    if (_animationQueue.Count > 0)
                    {
                        // grab and play the last animation cue in the queue
                        LoadNextCueInQueue();
                    }
                    else if (!AnimationCycle && this.OnAnimationEnd != null)
                    {
                        // do an animation finished callback
                        this.OnAnimationEnd();
                    }
                }
            }

#if DEBUG
            Profiler.Instance.EndBlock(Profiler_UpdateAnimation);
#endif
        }



        public override void Render(SceneRenderState srs)
        {
#if DEBUG
            Profiler.Instance.StartBlock("T2DAnimatedSprite.Render");
#endif

            // call base render
            base.Render(srs);

            // do not render if the data doesn't exist
            if (_animationData == null)
            {
#if DEBUG
                Profiler.Instance.EndBlock("T2DAnimatedSprite.Render");
#endif
                return;
            }

            // make sure the animation data has been interpreted
            if (_animationDataDirty)
                _InterpretAnimationData();

            // make sure we have a material assigned
            if (_quad.Material == null)
            {
#if DEBUG
                Profiler.Instance.EndBlock("T2DAnimatedSprite.Render");
#endif
                return;
            }

            // check if we need to update our current frame area
            if (_currentFrameAreaDirty)
                _currentFrameArea = _animationData.AnimationFramesList[_ac.CurrentFrame];

            _quad.SetupUVs(_currentFrameArea, FlipX, FlipY);

            Vector3 ScaleVector = new Vector3(0.5f * Size.X, 0.5f * Size.Y, 1);

            Matrix objToWorld = Matrix.Identity;

            // scale
            Matrix ScaleMatrix = Matrix.CreateScale(ScaleVector);

            // translate            
            Matrix TranslationMatrix = Matrix.CreateTranslation(new Vector3(Position.X, Position.Y, LayerDepth));

            // rotate            
            Matrix RotationMatrix = Matrix.CreateRotationZ(MathHelper.ToRadians(Rotation));

            objToWorld = ScaleMatrix * RotationMatrix * TranslationMatrix;

            // forward to quad
            _quad.Render(objToWorld, VisibilityLevel, srs);

#if DEBUG
            Profiler.Instance.EndBlock("T2DAnimatedSprite.Render");
#endif
        }



        public override void CopyTo(TorqueObject obj)
        {
            base.CopyTo(obj);

            T2DAnimatedSprite obj2 = (T2DAnimatedSprite)obj;

            obj2.AnimationTimeScale = AnimationTimeScale;
            obj2.CurrentTime = CurrentTime;
            obj2.StartFrame = StartFrame;
            obj2.RemoveOnFinished = RemoveOnFinished;
            obj2.AnimationData = AnimationData;
            obj2.PlayOnLoad = PlayOnLoad;
            obj2.AnimationPaused = AnimationPaused;
            obj2.OnFrameChange = OnFrameChange;
            obj2.OnAnimationEnd = OnAnimationEnd;
            obj2.RandomStart = RandomStart;
        }



        public override void Dispose()
        {
            _quad.Dispose();
            base.Dispose();
        }

        #endregion


        #region Private, protected, internal methods

        protected void _InterpretAnimationData()
        {
            // make sure the animated sprite has been registered
            // (this is done to prevent errors that occur when trying to assign these values
            // during desrerialization.
            if (!IsRegistered)
                return;

            // make sure we have an animation data assigned
            if (_animationData == null)
                return;

            // make sure the animation data has been initialized
            if (!_animationData.IsInitialized)
            {
                // try to init
                _animationData.Init();

                // if still not initialized animation data must be borked...
                // quit now and drop the animation data to skip further initialization
                if (!_animationData.IsInitialized)
                {
                    Assert.Fatal(false, "T2DAnimatedSprite._InterpretAnimationData() - Initialization of animation data failed. Animation will not play.");
                    _animationData = null;
                    return;
                }
            }

            // pass the data on to the animation controller
            _ac.AnimationFrameCount = _animationData.AnimationFramesList.Count;
            _ac.AnimationDuration = _animationData.AnimationDuration;
            _ac.AnimationCycle = _animationData.AnimationCycle;

            // pass the material from the animation data to the quad
            _quad.Material = _animationData.Material;

            // set the texture coordinates dirty
            _currentFrameAreaDirty = true;

            // reset the animation data dirty flag
            _animationDataDirty = false;
        }



        protected void _InitAnimation()
        {
            // make sure the animation data has been initialized
            if (_animationDataDirty)
                _InterpretAnimationData();

            // notify the animation controller to initialize the new animation
            _ac.InitAnimation();
        }



        protected bool _ValidateAnimationCue(T2DAnimationCue animCue)
        {
            // make sure we got an actual animation cue
            if (animCue == null)
                return false;

            // make sure that the animation data isn't null and has frames 
            if (animCue.AnimationData == null && animCue.AnimationData.AnimationFramesList.Count > 0)
                return false;

            // make sure the restore time is valid
            if (animCue.RestoreTime >= animCue.AnimationData.AnimationDuration
                || animCue.RestoreTime < 0.0f)
                return false;

            // success: return true...
            return true;
        }

        #endregion


        #region Private, protected, internal fields

        private bool _removeOnFinished;
        private bool _frameChanged;
        private bool _playOnLoad = true;
        private bool _isPaused = true;
        private RenderQuad _quad = new RenderQuad();
        private RectangleF _currentFrameArea;
        private bool _currentFrameAreaDirty;
        private T2DAnimationController _ac = new T2DAnimationController();
        private OnFrameChangeDelegate _onFrameChange;
        private OnAnimationEndDelegate _onAnimationEnd;

        private T2DAnimationData _animationData;
        private bool _animationDataDirty;
        private List<T2DAnimationCue> _animationQueue = new List<T2DAnimationCue>();

        private float _pauseTime = 0.0f;

        #endregion
    }
}

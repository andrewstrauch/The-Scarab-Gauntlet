//-----------------------------------------------------------------------------
// Torque X Game Engine
// Copyright © GarageGames.com, Inc.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using GarageGames.Torque.Core;
using GarageGames.Torque.Util;



namespace GarageGames.Torque.Sim
{
    /// <summary>
    /// Singleton object for managing all the players in a game.  Players are index from 0 to MaxPlayers-1 and can be looked up using the GetPlayer method:
    /// <para>
    ///     PlayerManager.Player player = PlayerManager.Instance.GetPlayer(0);
    /// </para>
    /// </summary>
    public class PlayerManager
    {
        /// <summary>
        /// Class which manages a single player in a game.  This class lets you configure what game object is controlled by the player
        /// and what input map is used to pass moves to the control object.  Arbitrary data can also be associated with players using the
        /// GetData and SetData methods.  E.g.:
        /// <para>
        /// </para>
        ///     player.SetData("score", 1000);    // player score
        /// <para>
        /// </para>
        ///     player.SetData("name", "Rupert"); // player name
        /// <para>
        /// </para>
        ///     player.SetData("trap1", false);   // 1st trap not yet sprung
        /// </summary>
        public class Player
        {

            #region Constructors

            public Player(MoveManager moveManager)
            {
                _moveManager = moveManager;
            }

            #endregion


            #region Public properties, operators, constants, and enums

            /// <summary>
            /// InputMap associated with this player.  New mappings can be made on the InputMap or a new
            /// map can be put in place.  Setting an InputMap results in it being pushed onto the InputManager
            /// (and the previous map being popped and setting the MoveManager on the InputMap to this 
            /// player's MoveManager.
            /// </summary>
            public InputMap InputMap
            {
                get { return _inputMap; }
                set
                {
                    if (_inputMap != null)
                    {
                        InputManager.Instance.PopInputMap(_inputMap);
                        _inputMap.MoveManager = null;
                    }

                    if (value != null)
                    {
                        InputManager.Instance.PushInputMap(value);
                        value.MoveManager = _moveManager;
                    }

                    _inputMap = value;
                }
            }



            /// <summary>
            /// The object which receives all moves generated by this player.  A new control object can be set at any
            /// time and old control objects can be restored.  This can be used to create a new game object each
            /// time the player's control object is destroyed in the game, or it can be used to transfer player control
            /// over one game object to another (for example, allowing the player to control a character object at one 
            /// time and a vehicle at another).
            /// </summary>
            public TorqueObject ControlObject
            {
                get { return _controlObject; }
                set
                {
                    if (value == _controlObject)
                        return;
                    if (_controlObject != null)
                    {
                        ProcessList.Instance.ClearMoveManager(_controlObject);
                        _moveManager._Consumer = null;
                    }

                    if (value != null)
                        ProcessList.Instance.SetMoveManager(value, _moveManager);

                    _controlObject = value;
                }
            }



            /// <summary>
            /// The Movemanager which generates all the moves for this player.  The MoveManager can be used to configure how the input for the
            /// object is mapped into moves.  E.g., the MoveManager controls whether buttons signal whenever down or only on make events, and how
            /// keyboard input is used to simulate sticks on the gamepad.
            /// </summary>
            public MoveManager MoveManager
            {
                get { return _moveManager; }
            }

            #endregion


            #region Public methods

            /// <summary>
            /// Retrieves data associated with a given player using the passed key.  
            /// </summary>
            /// <param name="key">Name data is stored under.</param>
            /// <param name="data">Retrieved data.</param>
            /// <returns>Retrieved data.</returns>
            public object GetData(String key, out object data)
            {
                data = null;

                if (_data != null)
                    _data.TryGetValue(key, out data);

                return data;
            }



            /// <summary>
            /// Store data associated with a given player using the passesd key.
            /// </summary>
            /// <param name="key">Name data is stored under.</param>
            /// <param name="data">Data to store.</param>
            public void SetData(String key, object data)
            {
                if (_data == null)
                    _data = new Dictionary<string, object>();

                _data[key] = data;
            }



            /// <summary>
            /// Retrieves data associated with a given player using the passed key.  
            /// </summary>
            /// <param name="key">Name data is stored under.</param>
            /// <param name="data">Retrieved data.</param>
            /// <returns>Retrieved data.</returns>
            public float GetData(String key, out float data)
            {
                data = 0.0f;

                if (_valueData != null)
                    _valueData.TryGetValue(key, out data);

                return data;
            }



            /// <summary>
            /// Store data associated with a given player using the passesd key.
            /// </summary>
            /// <param name="key">Name data is stored under.</param>
            /// <param name="data">Data to store.</param>
            public void SetData(String key, float data)
            {
                if (_valueData == null)
                    _valueData = new Dictionary<string, float>();

                _valueData[key] = data;
            }



            /// <summary>
            /// Retrieves data associated with a given player using the passed key.  
            /// </summary>
            /// <param name="key">Name data is stored under.</param>
            /// <param name="data">Retrieved data.</param>
            /// <returns>Retrieved data.</returns>
            public int GetData(String key, out int data)
            {
                float tmp = 0.0f;

                data = (int)GetData(key, out tmp);

                return data;
            }



            /// <summary>
            /// Store data associated with a given player using the passesd key.
            /// </summary>
            /// <param name="key">Name data is stored under.</param>
            /// <param name="data">Data to store.</param>
            public void SetData(String key, int val)
            {
                SetData(key, (float)val);
            }



            /// <summary>
            /// Retrieves data associated with a given player using the passed key.  
            /// </summary>
            /// <param name="key">Name data is stored under.</param>
            /// <param name="data">Retrieved data.</param>
            /// <returns>Retrieved data.</returns>
            public bool GetData(String key, out bool data)
            {
                float tmp = 0.0f;

                data = GetData(key, out tmp) > 0.5f;

                return data;
            }



            /// <summary>
            /// Store data associated with a given player using the passesd key.
            /// </summary>
            /// <param name="key">Name data is stored under.</param>
            /// <param name="data">Data to store.</param>
            public void SetData(String key, bool val)
            {
                SetData(key, val ? 1.0f : 0.0f);
            }



            /// <summary>
            /// Clear all data associated with a player.
            /// </summary>
            public void ResetData()
            {
                _valueData = null;
                _data = null;
            }

            #endregion


            #region Private, protected, internal fields

            InputMap _inputMap;
            MoveManager _moveManager;
            TorqueObject _controlObject;
            Dictionary<String, float> _valueData;
            Dictionary<String, object> _data;

            #endregion
        }


        #region Static methods, fields, constructors

        public static PlayerManager Instance
        {
            get { return _instance = _instance ?? new PlayerManager(); }
        }

        static PlayerManager _instance;

        #endregion


        #region Public properties, operators, constants, and enums

        /// <summary>
        /// Maximum number of players allowed.  If a player is indexed beyond the maximum
        /// it is considered an error.  By default this value is 4.
        /// </summary>
        public int MaxPlayers
        {
            get { return _maxPlayers; }
            set { _maxPlayers = value; }
        }

        #endregion


        #region Public methods

        /// <summary>
        /// Return the indexed player.  If the index is greater than or equal to MaxPlayers an
        /// error may result.
        /// </summary>
        /// <param name="playerIndex">Index of player.</param>
        /// <returns>The indexed player.</returns>
        public Player GetPlayer(int playerIndex)
        {
            if (!_CheckPlayerIndex(playerIndex))
            {
                Assert.Fatal(false, "Player index out of range -- increase MaxPlayers if more players desired.");
                return new Player(null); // useless player since move manager always null
            }
            return _players[playerIndex];
        }



        /// <summary>
        /// Return the player who controls this object.  If no player controls the object then returns null.
        /// </summary>
        /// <param name="controlObject">Object controlled by player.</param>
        /// <returns>Player controlling object or null if no player controls the object.</returns>
        public Player GetPlayer(TorqueObject controlObject)
        {
            int idx = GetPlayerIndex(controlObject);

            if (idx < 0)
                return null;

            return _players[idx];
        }



        /// <summary>
        /// Return the index of the player who controls this object.  If no player controls the object then returns -1.
        /// </summary>
        /// <param name="controlObject">Object controlled by player.</param>
        /// <returns>Index of player or -1 if no player controls the object.</returns>
        public int GetPlayerIndex(TorqueObject controlObject)
        {
            for (int i = 0; i < _players.Count; i++)
                if (_players[i].ControlObject == controlObject)
                    return i;

            return -1;
        }

        #endregion


        #region Private, protected, internal methods

        bool _CheckPlayerIndex(int playerIndex)
        {
            Assert.Fatal(playerIndex >= 0 && playerIndex < _maxPlayers, "Player index out of range");

            while (_players.Count <= Math.Min(_maxPlayers, playerIndex))
            {
                Player player = new Player(new MoveManager());
                player.InputMap = new InputMap();
                _players.Add(player);
            }

            return playerIndex >= 0 && playerIndex < _players.Count;
        }

        #endregion


        #region Private, protected, internal fields

        int _maxPlayers = 4;
        List<Player> _players = new List<Player>();

        #endregion

    }
}

//-----------------------------------------------------------------------------
// Torque X Game Engine
// Copyright © GarageGames.com, Inc.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using System.Diagnostics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using GarageGames.Torque.Core;
using GarageGames.Torque.Materials;
using GarageGames.Torque.SceneGraph;
using GarageGames.Torque.GFX;
using GarageGames.Torque.RenderManager;
using GarageGames.Torque.Util;
using GarageGames.Torque.MathUtil;
using GarageGames.Torque.Sim;
using GarageGames.Torque.GameUtil;



namespace GarageGames.Torque.T2D
{
    /// <summary>
    /// T2DParticleEmitterData describes the type of particles and the lifetime characteristics of particles
    /// generated by a particular particle emitter.  Note: many of the particle emitter data properties are 
    /// T2DKeyGraphs.  These are keyframe animations of variables over time.  There are typically three 
    /// versions of each variable: base, variation, and life, name, e.g., SizeBase, SizeVariation,
    /// and SizeLife.  Base determines the center of the range whereas variation determines the full range (+/- half
    /// variation).  These values are determined once per particle, with emitter lifetime being used as the index.  
    /// The life keygraph determines a scale value which varies over the lifetime of the particle itself (as opposed
    /// to the emitter).
    /// </summary>
    public class T2DParticleEmitterData : IDisposable
    {
        #region Constructors

        public T2DParticleEmitterData()
        {
            // Create/Register Graph Properties.
            _particleLife = new T2DKeyGraph_BaseVariation(2.0f);
            _quantity = new T2DKeyGraph_BaseVariation(10.0f);
            _sizeX = new T2DKeyGraph_BaseVariationLife(2.0f);
            _sizeY = new T2DKeyGraph_BaseVariationLife(2.0f);
            _speed = new T2DKeyGraph_BaseVariationLife(2.0f);
            _spin = new T2DKeyGraph_BaseVariationLife(0.0f);
            _fixedForce = new T2DKeyGraph_BaseVariationLife(0.0f);
            _randomMotion = new T2DKeyGraph_BaseVariationLife(0.0f);
            _emissionForce = new T2DKeyGraph_BaseVariation(5.0f);
            _emissionAngle = new T2DKeyGraph_BaseVariation(0.0f);
            _emissionArc = new T2DKeyGraph_BaseVariation(360.0f);
            _colorRed = new T2DKeyGraph_Life();
            _colorGreen = new T2DKeyGraph_Life();
            _colorBlue = new T2DKeyGraph_Life();
            _visibility = new T2DKeyGraph_Life();

            // Reset Emitter Values.
            ResetValues();
        }



        public T2DParticleEmitterData(String name)
            : this()
        {
            // Set Name.
            Name = name;
        }

        #endregion


        #region Public properties, operators, constants, and enums

        #region Enumerations

        /// <summary>
        /// Particle Orientation Mode.  Determines how particles will be oriented when first emitted.
        /// </summary>
        public enum ParticleOrientationMode
        {
            /// <summary>
            /// Orientation of particles will be aligned with particle velocity (plus OrientationAngleOffset).
            /// </summary>
            Aligned,
            /// <summary>
            /// Orientation of new particles will be equal to OrientationAngleOffset.
            /// </summary>
            Fixed,
            /// <summary>
            /// Orientation of new particles will be random values centered around OrientationAngleOffset
            /// plus or minus half of OrientationRandomArc.
            /// </summary>
            Random
        }



        /// <summary>
        /// Emitter Area Type.
        /// </summary>
        public enum EmitterAreaType
        {
            /// <summary>
            /// Emit all particles at the effect center.
            /// </summary>
            Point,
            /// <summary>
            /// Emit particles randomly along a line along the x-axis.  
            /// Particles will be offset in x by random number determined by the size of the
            /// parent effect.
            /// </summary>
            LineX,
            /// <summary>
            /// Emit particles randomly along a line along the y-axis.  
            /// Particles will be offset in y by random number determined by the size of the
            /// parent effect.
            /// </summary>
            LineY,
            /// <summary>
            /// Emit particles randomly within a rectangular region. If FixedAreaAspect is false then 
            /// x and y offset will be determined as in LineX and LineY, otherwise x and y will be
            /// determined as in LineX.
            /// </summary>
            Rectangle
        }

        #endregion ///Enumerations

        #region T2DKeyGraph Properties

        // -------------------------------------------------------------
        // Graph Properties.
        // -------------------------------------------------------------

        /// <summary>
        /// Used to determine the base lifetime for particles.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph ParticleLifeBase
        {
            get
            {
                return _particleLife.Base;
            }
            set
            {
                _particleLife.Base = value;
            }
        }



        /// <summary>
        /// Used to determine the base lifetime for particles.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph ParticleLifeVariation
        {
            get
            {
                return _particleLife.Variation;
            }
            set
            {
                _particleLife.Variation = value;
            }
        }



        /// <summary>
        /// Used to determine the rate at which particles are emitted (particles/sec).
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph QuantityBase
        {
            get
            {
                return _quantity.Base;
            }
            set
            {
                _quantity.Base = value;
            }
        }



        /// <summary>
        /// Used to determine the rate at which particles are emitted (particles/sec).
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph QuantityVariation
        {
            get
            {
                return _quantity.Variation;
            }
            set
            {
                _quantity.Variation = value;
            }
        }



        /// <summary>
        /// Used to determine the size of particles along the x dimension.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph SizeXBase
        {
            get
            {
                return _sizeX.Base;
            }
            set
            {
                _sizeX.Base = value;
            }
        }



        /// <summary>
        /// Used to determine the size of particles along the x dimension.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph SizeXVariation
        {
            get
            {
                return _sizeX.Variation;
            }
            set
            {
                _sizeX.Variation = value;
            }
        }



        /// <summary>
        /// Used to determine the size of particles along the x dimension.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph SizeXLife
        {
            get
            {
                return _sizeX.Life;
            }
            set
            {
                _sizeX.Life = value;
            }
        }



        /// <summary>
        /// Used to determine the size of particles along the y dimension.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph SizeYBase
        {
            get
            {
                return _sizeY.Base;
            }
            set
            {
                _sizeY.Base = value;
            }
        }



        /// <summary>
        /// Used to determine the size of particles along the y dimension.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph SizeYVariation
        {
            get
            {
                return _sizeY.Variation;
            }
            set
            {
                _sizeY.Variation = value;
            }
        }



        /// <summary>
        /// Used to determine the size of particles along the y dimension.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph SizeYLife
        {
            get
            {
                return _sizeY.Life;
            }
            set
            {
                _sizeY.Life = value;
            }
        }



        /// <summary>
        /// Used to determine a scale to apply to speed (which is determined from 
        /// FixedForce and RandomMotion key graphs).
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph SpeedBase
        {
            get
            {
                return _speed.Base;
            }
            set
            {
                _speed.Base = value;
            }
        }



        /// <summary>
        /// Used to determine a scale to apply to speed (which is determined from 
        /// FixedForce and RandomMotion key graphs).
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph SpeedVariation
        {
            get
            {
                return _speed.Variation;
            }
            set
            {
                _speed.Variation = value;
            }
        }



        /// <summary>
        /// Used to determine a scale to apply to speed (which is determined from 
        /// FixedForce and RandomMotion key graphs).
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph SpeedLife
        {
            get
            {
                return _speed.Life;
            }
            set
            {
                _speed.Life = value;
            }
        }



        /// <summary>
        /// Used to determine rotation rate of particles.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph SpinBase
        {
            get
            {
                return _spin.Base;
            }
            set
            {
                _spin.Base = value;
            }
        }



        /// <summary>
        /// Used to determine rotation rate of particles.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph SpinVariation
        {
            get
            {
                return _spin.Variation;
            }
            set
            {
                _spin.Variation = value;
            }
        }



        /// <summary>
        /// Used to determine rotation rate of particles.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph SpinLife
        {
            get
            {
                return _spin.Life;
            }
            set
            {
                _spin.Life = value;
            }
        }



        /// <summary>
        /// Used to determine strength of force to apply to particle over it's lifetime.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph FixedForceBase
        {
            get
            {
                return _fixedForce.Base;
            }
            set
            {
                _fixedForce.Base = value;
            }
        }



        /// <summary>
        /// Used to determine strength of force to apply to particle over it's lifetime.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph FixedForceVariation
        {
            get
            {
                return _fixedForce.Variation;
            }
            set
            {
                _fixedForce.Variation = value;
            }
        }



        /// <summary>
        /// Used to determine strength of force to apply to particle over it's lifetime.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph FixedForceLife
        {
            get
            {
                return _fixedForce.Life;
            }
            set
            {
                _fixedForce.Life = value;
            }
        }



        /// <summary>
        /// Used to determine strength of random motion applied to particle.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph RandomMotionBase
        {
            get
            {
                return _randomMotion.Base;
            }
            set
            {
                _randomMotion.Base = value;
            }
        }



        /// <summary>
        /// Used to determine strength of random motion applied to particle.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph RandomMotionVariation
        {
            get
            {
                return _randomMotion.Variation;
            }
            set
            {
                _randomMotion.Variation = value;
            }
        }



        /// <summary>
        /// Used to determine strength of random motion applied to particle.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph RandomMotionLife
        {
            get
            {
                return _randomMotion.Life;
            }
            set
            {
                _randomMotion.Life = value;
            }
        }



        /// <summary>
        /// Used to determine initial velocity when particle
        /// is first emitted.  Note: if UseEffectEmission then
        /// this value is used and values on effect are used instead.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph EmissionForceBase
        {
            get
            {
                return _emissionForce.Base;
            }
            set
            {
                _emissionForce.Base = value;
            }
        }



        /// <summary>
        /// Used to determine initial velocity when particle
        /// is first emitted.  Note: if UseEffectEmission then
        /// this value is used and values on effect are used instead.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph EmissionForceVariation
        {
            get
            {
                return _emissionForce.Variation;
            }
            set
            {
                _emissionForce.Variation = value;
            }
        }



        /// <summary>
        /// Used to determine emission angle of particles.  Note: if 
        /// UseEffectEmission then this value is used and values on
        /// effect are used instead.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph EmissionAngleBase
        {
            get
            {
                return _emissionAngle.Base;
            }
            set
            {
                _emissionAngle.Base = value;
            }
        }



        /// <summary>
        /// Used to determine emission angle of particles.  Note: if 
        /// UseEffectEmission then this value is used and values on
        /// effect are used instead.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph EmissionAngleVariation
        {
            get
            {
                return _emissionAngle.Variation;
            }
            set
            {
                _emissionAngle.Variation = value;
            }
        }



        /// <summary>
        /// Used to determine emission angle of particles.  Note: if 
        /// UseEffectEmission then this value is used and values on
        /// effect are used instead.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph EmissionArcBase
        {
            get
            {
                return _emissionArc.Base;
            }
            set
            {
                _emissionArc.Base = value;
            }
        }



        /// <summary>
        /// Used to determine emission angle of particles.  Note: if 
        /// UseEffectEmission then this value is used and values on
        /// effect are used instead.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph EmissionArcVariation
        {
            get
            {
                return _emissionArc.Variation;
            }
            set
            {
                _emissionArc.Variation = value;
            }
        }



        /// <summary>
        /// Used to determine the red color of particles.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph RedChannelLife
        {
            get
            {
                return _colorRed.Life;
            }
            set
            {
                _colorRed.Life = value;
            }
        }



        /// <summary>
        /// Used to determine the green color of particles.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph GreenChannelLife
        {
            get
            {
                return _colorGreen.Life;
            }
            set
            {
                _colorGreen.Life = value;
            }
        }



        /// <summary>
        /// Used to determine the blue color of particles.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph BlueChannelLife
        {
            get
            {
                return _colorBlue.Life;
            }
            set
            {
                _colorBlue.Life = value;
            }
        }



        /// <summary>
        /// Used to determine the visibility of particles.
        /// </summary>
        [TorqueXmlDeserializeInPlace]
        public T2DKeyGraph VisibilityLife
        {
            get
            {
                return _visibility.Life;
            }
            set
            {
                _visibility.Life = value;
            }
        }

        #endregion //T2DKeyGraph Properties

        #region Non-T2DKeyGraph Properties

        // -------------------------------------------------------------
        // Non-Graph Properties.
        // -------------------------------------------------------------

        /// <summary>
        /// If true, don't render emitter.
        /// </summary>
        public bool Hidden
        {
            get
            {
                return _hidden;
            }
            set
            {
                _hidden = value;
            }
        }



        /// <summary>
        /// If true, then y size of particle will be set to equalthe x size.
        /// </summary>
        public bool FixedParticleAspect
        {
            get
            {
                return _fixedParticleAspect;
            }
            set
            {
                _fixedParticleAspect = value;
            }
        }



        /// <summary>
        /// If  true then when figuring the area of emission for an emitter,
        /// the y size will be set to equal the x size.
        /// </summary>
        public bool FixedAreaAspect
        {
            get
            {
                return _fixedAreaAspect;
            }
            set
            {
                _fixedAreaAspect = value;
            }
        }



        /// <summary>
        /// Sets the angle in degrees of the fixed force applied to each particle.
        /// </summary>
        public float FixedForceAngle
        {
            get
            {
                return _fixedForceAngle;
            }
            set
            {
                // Set Angle.
                _fixedForceAngle = value;

                // Convert to radians.
                float forceAngleRad = MathHelper.ToRadians(_fixedForceAngle);
                // Calculate Force Direction.
                _fixedForceDirection.X = (float)Math.Sin(forceAngleRad);
                _fixedForceDirection.Y = (float)-Math.Cos(forceAngleRad);
            }
        }



        /// <summary>
        /// The direction of the fixed force applied to each particle.
        /// </summary>
        public Vector2 FixedForceDirection
        {
            get
            {
                return _fixedForceDirection;
            }
        }



        /// <summary>
        /// Set the particle orientation mode. Determines how particles 
        /// will be oriented when first emitted.
        /// </summary>
        public ParticleOrientationMode ParticleOrientation
        {
            get
            {
                return _particleOrientationMode;
            }
            set
            {
                _particleOrientationMode = value;
            }
        }



        /// <summary>
        /// Offset orientation of new particles by this value.
        /// </summary>
        public float OrientationAngleOffset
        {
            get
            {
                return _orientationAngleOffset;
            }
            set
            {
                _orientationAngleOffset = value;
            }
        }



        /// <summary>
        /// Used to determine random orientation of particles.  The random arc is the range
        /// of the possible orientations.
        /// </summary>
        public float OrientationRandomArc
        {
            get
            {
                return _orientationRandomArc;
            }
            set
            {
                _orientationRandomArc = value;
            }
        }



        /// <summary>
        /// Used to produce an initial burst of particles.  InitialAge is added to
        /// initial emitter time when determining how many particles to generate over
        /// early time steps.  Note that true particle and effect time is still used to
        /// determine particle parameters.
        /// </summary>
        public float InitialAge
        {
            get
            {
                return _initialAge;
            }
            set
            {
                _initialAge = value;
            }
        }



        /// <summary>
        /// Set the area type over which particle emissions will occur.
        /// </summary>
        public EmitterAreaType EmitterArea
        {
            get
            {
                return _emitterAreaType;
            }
            set
            {
                _emitterAreaType = value;
            }
        }



        /// <summary>
        /// Point about which particles rotate.  Note that pivot point is specified in
        /// unscaled particle space, so that 0,0 is in center and (1,1), (-1,1), (1,-1),
        /// and (-1,-1) are the corners of the particle.
        /// </summary>
        public Vector2 ParticlePivotPoint
        {
            get
            {
                return _particlePivotPoint;
            }
            set
            {
                _particlePivotPoint = value;
            }
        }



        /// <summary>
        /// If true the effect rather than emitter is used to determine
        /// emission velocity.
        /// </summary>
        public bool UseEffectEmission
        {
            get
            {
                return _useEffectEmission;
            }
            set
            {
                _useEffectEmission = value;
            }
        }



        /// <summary>
        /// If true then particles will be emitted reltive to parent particle
        /// effect.
        /// </summary>
        public bool LinkEmissionRotation
        {
            get
            {
                return _linkEmissionRotation;
            }
            set
            {
                _linkEmissionRotation = value;
            }
        }



        /// <summary>
        /// If true then position of particles is relative to the emitter.  As the
        /// emitter moves so do the particles.
        /// </summary>
        public bool AttachPositionToEmitter
        {
            get
            {
                return _attachPositionToEmitter;
            }
            set
            {
                _attachPositionToEmitter = value;
            }
        }



        /// <summary>
        /// If true then particles will rotate around emitter as it rotates
        /// (i.e., "particle space" is "object space").  Note that if this
        /// property is true then AttachPositionToEmitter is forced to true.
        /// </summary>
        public bool AttachRotationToEmitter
        {
            get
            {
                return _attachRotationToEmitter;
            }
            set
            {
                _attachRotationToEmitter = value;

                // Is rotation attached to the emitter?
                if (_attachRotationToEmitter)
                {
                    // Yes, so we *must* have position attached as well!
                    _attachPositionToEmitter = true;
                }
            }
        }



        /// <summary>
        /// If true then only one particle is generated.  This is for debug
        /// purposes only.
        /// </summary>
        public bool SingleParticle
        {
            get
            {
                return _singleParticle;
            }
            set
            {
                _singleParticle = value;
            }
        }



        /// <summary>
        /// If true then older particles are rendered on
        /// top of newer particles.  Otherwise, oldest particles
        /// are rendered underneath newer particles.
        /// </summary>
        public bool FirstInFrontOrder
        {
            get
            {
                return _firstInFrontOrder;
            }
            set
            {
                _firstInFrontOrder = value;
            }
        }

        #endregion //Non-T2DKeyGraph Properties

        #region Misc Properties

        /// <summary>
        /// Name of particle emitter.
        /// </summary>
        public String Name
        {
            get
            {
                return _name;
            }
            set
            {
                _name = value;
            }
        }



        /// <summary>
        /// Name of material used for rendering particles.
        /// </summary>
        public String MaterialName
        {
            get
            {
                // Valid Material Name?
                if (_materialName != null)
                {
                    // Yes, so return it.
                    return _materialName;
                }
                else
                {
                    // No, so return empty.
                    return String.Empty;
                }
            }
            set
            {
                // Set Material name.
                _materialName = value;
                // Set Material.
                _material = MaterialManager.Lookup(_materialName);
            }
        }



        /// <summary>
        /// Material used for rendering particles.
        /// </summary>
        public RenderMaterial Material
        {
            get
            {
                return _material;
            }
            set
            {
                // Set Material.
                _material = value;

                // Valid Material?
                if (_material != null)
                {
                    if (_material is SimpleMaterial)
                        (_material as SimpleMaterial).IsColorBlended = true;

                    // Yes, so lookup material name.
                    _materialName = _material.NameMapping;
                }
                else
                {
                    // No, so set name to empty.
                    _materialName = String.Empty;
                }
            }
        }



        public int MaterialRegionIndex
        {
            get { return _materialRegionIndex; }
            set { _materialRegionIndex = value; }
        }



        public Vector2[] TextureCoords
        {
            get
            {
                if (_textureCoords == null)
                {
                    _textureCoords = new Vector2[4];
                    Material.GetRegionCoords(MaterialRegionIndex,
                                            out _textureCoords[0], out _textureCoords[1],
                                            out _textureCoords[2], out _textureCoords[3]);
                }

                return _textureCoords;
            }
            set { _textureCoords = value; }
        }

        #endregion //Misc Properties

        #endregion


        #region Public methods

        /// <summary>
        /// Reset emitter data values to defaults.
        /// </summary>
        public virtual void ResetValues()
        {
            // Reset Values.
            Hidden = false;
            FixedParticleAspect = true;
            FixedAreaAspect = true;
            FixedForceAngle = 0.0f;
            ParticleOrientation = ParticleOrientationMode.Fixed;
            OrientationAngleOffset = 0.0f;
            OrientationRandomArc = 360.0f;
            InitialAge = 0.0f;
            EmitterArea = EmitterAreaType.Point;
            ParticlePivotPoint = new Vector2(0.0f, 0.0f);
            UseEffectEmission = false;
            LinkEmissionRotation = false;
            AttachPositionToEmitter = false;
            AttachRotationToEmitter = false;
            FirstInFrontOrder = false;
        }

        #endregion


        #region Private, protected, internal fields

        // Name.
        private String _name = String.Empty;

        // Render Material.
        String _materialName = String.Empty;
        RenderMaterial _material;
        int _materialRegionIndex;
        Vector2[] _textureCoords;

        // Graph Properties.
        T2DKeyGraph_BaseVariation _particleLife;
        T2DKeyGraph_BaseVariation _quantity;
        T2DKeyGraph_BaseVariationLife _sizeX;
        T2DKeyGraph_BaseVariationLife _sizeY;
        T2DKeyGraph_BaseVariationLife _speed;
        T2DKeyGraph_BaseVariationLife _spin;
        T2DKeyGraph_BaseVariationLife _fixedForce;
        T2DKeyGraph_BaseVariationLife _randomMotion;
        T2DKeyGraph_BaseVariation _emissionForce;
        T2DKeyGraph_BaseVariation _emissionAngle;
        T2DKeyGraph_BaseVariation _emissionArc;
        T2DKeyGraph_Life _colorRed;
        T2DKeyGraph_Life _colorGreen;
        T2DKeyGraph_Life _colorBlue;
        T2DKeyGraph_Life _visibility;

        // Other Properties.
        bool _hidden;
        bool _fixedParticleAspect;
        bool _fixedAreaAspect;
        Vector2 _fixedForceDirection;
        float _fixedForceAngle;
        ParticleOrientationMode _particleOrientationMode;
        float _orientationAngleOffset;
        float _orientationRandomArc;
        float _initialAge;
        EmitterAreaType _emitterAreaType;
        Vector2 _particlePivotPoint;
        bool _useEffectEmission;
        bool _linkEmissionRotation;
        bool _singleParticle;
        bool _attachPositionToEmitter;
        bool _attachRotationToEmitter;
        bool _firstInFrontOrder;

        #endregion

        #region IDisposable Members

        public virtual void Dispose()
        {
            _material = null;
        }

        #endregion
    }



    /// <summary>
    /// Particle Emitter.
    /// </summary>
    sealed public class T2DParticleEmitter : IIndexPoolerChain, IDisposable
    {
        #region Constructors

        // Default Constructor.
        private T2DParticleEmitter()
        {
        }

        // Parameter Constructor.
        public T2DParticleEmitter(T2DParticleEffect effect, T2DParticleEmitterData emitterData)
            : this()
        {
            // Set Parent Effect.
            _parentEffect = effect;

            // Set Current Emitter Data.
            CurrentEmitterData = emitterData;
        }

        #endregion


        #region Public properties, operators, constants, and enums

        /// <summary>
        /// Index of first particle in particle pool.  Implements IIndexPoolerChain.Head.
        /// </summary>
        [XmlIgnore]
        public int Head
        {
            get
            {
                return _freeHeadIndex;
            }
            set
            {
                _freeHeadIndex = value;
            }
        }



        /// <summary>
        /// Index of last particle in particle pool.  Implements IIndexPoolerChain.Tail.
        /// </summary>
        [XmlIgnore]
        public int Tail
        {
            get
            {
                return _freeTailIndex;
            }
            set
            {
                _freeTailIndex = value;
            }
        }



        /// <summary>
        /// Number of particles allocated in particle pool.  Implements IIndexPoolerChain.Allocated.
        /// </summary>
        [XmlIgnore]
        public int Allocated
        {
            get
            {
                return _allocatedPoolCount;
            }
            set
            {
                _allocatedPoolCount = value;
            }
        }



        [XmlIgnore]
        public Matrix ParticleRenderTransform
        {
            get
            {
                return _particleRenderTransform;
            }
        }



        [XmlIgnore]
        public Matrix ParticleRotation
        {
            get
            {
                return _particleRotation;
            }
        }



        /// <summary>
        ///  Current Emitter Data.  Determines most of the parameters which effect
        /// the generation of particles.
        /// </summary>
        public T2DParticleEmitterData CurrentEmitterData
        {
            get
            {
                return _emitterData;
            }
            internal set
            {
                // Already got emitter-data?
                if (_emitterData != null)
                {
                    // Yes, so clear particles.
                    ClearParticles();
                }

                // Set Emitter Data.
                _emitterData = value;

                _FindMaxParticleSize();
                _CheckLifeTime();
            }
        }

        #endregion


        #region Public methods

        /// <summary>
        /// Clear all particles from the particle pool.
        /// </summary>
        public void ClearParticles()
        {
            // Free All Allocated Particles.
            T2DParticleManager.Instance.FreeAllParticles(this);
        }



        /// <summary>
        /// Create given number of particles.
        /// </summary>
        /// <param name="newParticles">Number of particles to generate.</param>
        public void CreateParticles(int newParticles)
        {
            // Allocate Particles.
            int freeIndex = T2DParticleManager.Instance.AllocateParticles(newParticles, this);

            // Fetch Particle Manager Pool.
            T2DParticle[] particleManagerPool = T2DParticleManager.Instance.Pool;

            // Initialize particles.
            for (int n = 0; n < newParticles; ++n)
            {
                // Initialize particle.
                InitializeParticle(ref particleManagerPool[freeIndex]);

                // Fetch next reference.
                freeIndex = particleManagerPool[freeIndex].Next;
            }
        }



        /// <summary>
        /// Initialize given particle.
        /// </summary>
        /// <param name="particle">Particle to initialize.</param>
        public void InitializeParticle(ref T2DParticle particle)
        {
            // Fetch Effect Age.
            float effectAge = _parentEffect.Age;
            // Fetch Effect Position.
            Vector2 effectPosition = _parentEffect.Position;
            // Fetch Parent Effect Effect-Data.
            T2DParticleEffectData parentEffectData = _parentEffect.CurrentEffectData;

            // **********************************************************************************************************************
            // Calculate Particle Position...
            // **********************************************************************************************************************

            // Single Particle?
            if (_emitterData.SingleParticle)
            {
                // Yes, so are we using effect position?
                if (_emitterData.AttachPositionToEmitter)
                {
                    // Yes, so set position.
                    particle.Position = Vector2.Zero;
                }
                else
                {
                    // No, so use effect position.
                    particle.Position = effectPosition;
                }
            }
            else
            {
                // No, so select emitter type.
                switch (_emitterData.EmitterArea)
                {
                    // Point.
                    case T2DParticleEmitterData.EmitterAreaType.Point:
                        {
                            // Set Particle position.
                            particle.Position = Vector2.Zero;

                        } break;

                    // LineX.
                    case T2DParticleEmitterData.EmitterAreaType.LineX:
                        {
                            // Calculate Area Size X.
                            float areaSizeX = 0.5f * TorqueUtil.GetFastRandomFloat(0.0f, _parentEffect.Size.X);


                            // Calculate Sign.
                            if ((TorqueUtil.GetFastRandomInt() & 1) == 0)
                            {
                                areaSizeX = -areaSizeX;
                            }


                            // Choose particle location.
                            particle.PositionX = areaSizeX;
                            particle.PositionY = 0.0f;

                        } break;

                    // LineY.
                    case T2DParticleEmitterData.EmitterAreaType.LineY:
                        {
                            // Calculate Area Size Y.
                            float areaSizeY = 0.5f * TorqueUtil.GetFastRandomFloat(0.0f, _parentEffect.Size.Y);


                            // Calculate Sign.
                            if ((TorqueUtil.GetFastRandomInt() & 1) == 0)
                            {
                                areaSizeY = -areaSizeY;
                            }

                            // Choose particle location.
                            particle.PositionX = 0.0f;
                            particle.PositionY = 0.0f + areaSizeY;

                        } break;

                    // Rectangle.
                    case T2DParticleEmitterData.EmitterAreaType.Rectangle:
                        {
                            // Calculate Min/Max Area Size X.
                            float minAreaSizeX = 0.0f;
                            float maxAreaSizeX = 0.5f * _parentEffect.Size.X;

                            // Inline Clamp.
                            if (maxAreaSizeX < minAreaSizeX)
                            {
                                maxAreaSizeX = minAreaSizeX;
                            }

                            // Choose Random Area.
                            float areaSizeX = TorqueUtil.GetFastRandomFloat(maxAreaSizeX);


                            // Assume Fixed Area Aspect.
                            float minAreaSizeY;
                            float maxAreaSizeY;
                            float areaSizeY;

                            if (_emitterData.FixedAreaAspect)
                            {
                                // Yes, so calculate Min/Max Area Size Y (using X).
                                minAreaSizeY = minAreaSizeX;
                                maxAreaSizeY = maxAreaSizeX;
                            }
                            else
                            {
                                // No, so calculate Area Size Y.
                                minAreaSizeY = 0.0f;
                                maxAreaSizeY = 0.5f * _parentEffect.Size.Y;
                            }

                            // Inline Clamp.
                            if (maxAreaSizeY < minAreaSizeY)
                            {
                                maxAreaSizeY = minAreaSizeY;
                            }

                            // Choose Random Area.
                            areaSizeY = TorqueUtil.GetFastRandomFloat(maxAreaSizeY);


                            // Inner Region X?
                            if (areaSizeX < minAreaSizeX && areaSizeY < minAreaSizeY)
                            {
                                // Yes, so randomize within outer region.
                                areaSizeX = minAreaSizeX + (areaSizeX % Math.Abs(maxAreaSizeX - minAreaSizeX + Epsilon.Value));
                            }

                            // Inner Region Y?
                            if (areaSizeY < minAreaSizeY && areaSizeX < minAreaSizeX)
                            {
                                // Yes, so randomize within outer region.
                                areaSizeY = minAreaSizeY + (areaSizeY % Math.Abs(maxAreaSizeY - minAreaSizeY + Epsilon.Value));
                            }

                            // Calculate Sign.
                            int areaFlip = TorqueUtil.GetFastRandomInt();
                            if ((areaFlip & 1) == 0)
                            {
                                areaSizeX = -areaSizeX;
                            }

                            // Calculate Sign.
                            if ((areaFlip & 2) == 0)
                            {
                                areaSizeY = -areaSizeY;
                            }

                            // Choose particle location.
                            particle.PositionX = areaSizeX;
                            particle.PositionY = areaSizeY;

                        } break;
                }

                // Attach position to emitter?
                if (!_emitterData.AttachPositionToEmitter)
                {
                    // No, so attach rotation to emitter?
                    if (!_emitterData.AttachRotationToEmitter)
                    {
                        // No, so we need to fully transform in non-scaled effect world-space.
                        particle.Position = Vector2.Transform(particle.Position, _parentEffect.EffectRotationTranslationMatrix);
                    }
                    else
                    {
                        // Yes, so we need to transform in non-scaled, non-rotated effect world-space.
                        particle.Position = Vector2.Transform(particle.Position, _parentEffect.EffectTranslationMatrix);
                    }
                }
            }


            // **********************************************************************************************************************
            // Calculate Particle Lifetime.
            // **********************************************************************************************************************

            // Reset Age.
            particle.Age = 0.0f;

            // Calculate Lifetime.
            particle.Lifetime = T2DKeyGraph.CalcGraphBVE(_emitterData.ParticleLifeBase, _emitterData.ParticleLifeVariation, parentEffectData.ParticleLifeScale, effectAge);
            if (particle.Lifetime < Epsilon.Value)
                particle.Lifetime = Epsilon.Value;

            // **********************************************************************************************************************
            // Calculate Particle Size.
            // **********************************************************************************************************************

            // Calculate SizeX.
            particle.SizeX = T2DKeyGraph.CalcGraphBVE(_emitterData.SizeXBase, _emitterData.SizeXVariation, parentEffectData.SizeXScale, effectAge);
            particle.SizeY = _emitterData.FixedParticleAspect ? particle.SizeX : T2DKeyGraph.CalcGraphBVE(_emitterData.SizeYBase, _emitterData.SizeYVariation, parentEffectData.SizeYScale, effectAge);
            Assert.Fatal(particle.SizeX > 0.0f && particle.SizeY > 0.0f, "Zero or negative size particles not recommended.");


            // **********************************************************************************************************************
            // Calculate Speed, Fixed-Force, Random Motion
            // **********************************************************************************************************************

            if (_emitterData.SingleParticle)
            {
                particle.Speed = 0.0f;
                particle.FixedForce = 0.0f;
                particle.RandomMotion = 0.0f;
            }
            else
            {
                particle.Speed = T2DKeyGraph.CalcGraphBVE(_emitterData.SpeedBase, _emitterData.SpeedVariation, parentEffectData.SpeedScale, effectAge);
                particle.FixedForce = T2DKeyGraph.CalcGraphBVE(_emitterData.FixedForceBase, _emitterData.FixedForceVariation, parentEffectData.FixedForceScale, effectAge);
                particle.RandomMotion = T2DKeyGraph.CalcGraphBVE(_emitterData.RandomMotionBase, _emitterData.RandomMotionVariation, parentEffectData.RandomMotionScale, effectAge);
            }


            // **********************************************************************************************************************
            // Calculate Spin.
            // **********************************************************************************************************************

            particle.Spin = T2DKeyGraph.CalcGraphBVE(_emitterData.SpinBase, _emitterData.SpinVariation, parentEffectData.SpinScale, effectAge);


            // **********************************************************************************************************************
            // Calculate Emission Angle.
            // **********************************************************************************************************************

            float emissionForce = 0.0f;
            float emissionAngle = 0.0f;
            float emissionArc = 0.0f;

            // Ignore if we're using Single Particle.
            if (!_emitterData.SingleParticle)
            {
                // Are we using effect emission?
                if (_emitterData.UseEffectEmission)
                {
                    // Yes, so calculate emission from effect.
                    emissionForce = -T2DKeyGraph.CalcGraphBV(parentEffectData.EmissionForceBase, parentEffectData.EmissionForceVariation, effectAge);
                    emissionAngle = T2DKeyGraph.CalcGraphBV(parentEffectData.EmissionAngleBase, parentEffectData.EmissionAngleVariation, effectAge);
                    // NOTE:-   We're only interested in half the emission arc!
                    emissionArc = T2DKeyGraph.CalcGraphBV(parentEffectData.EmissionArcBase, parentEffectData.EmissionArcVariation, effectAge) * 0.5f;

                }
                else
                {
                    // No, so calculate emission from emitter.
                    emissionForce = T2DKeyGraph.CalcGraphBV(_emitterData.EmissionForceBase, _emitterData.EmissionForceVariation, effectAge);

                    // No, so calculate standard emission angle.
                    emissionAngle = T2DKeyGraph.CalcGraphBV(_emitterData.EmissionAngleBase, _emitterData.EmissionAngleVariation, effectAge);

                    // Calculate Emission Arc.
                    // NOTE:-   We're only interested in half the emission arc!
                    emissionArc = T2DKeyGraph.CalcGraphBV(_emitterData.EmissionArcBase, _emitterData.EmissionArcVariation, effectAge) * 0.5f;
                }

                // Is the emission rotation linked?
                if (_emitterData.LinkEmissionRotation)
                {
                    // Yes, so add effect rotation onto emission angle.
                    emissionAngle += _parentEffect.Rotation;
                }

                // Calculate final emission angle by choosing random arc.
                emissionAngle = TorqueUtil.GetFastRandomFloat(emissionAngle - emissionArc, emissionAngle + emissionArc) % 360.0f;
                float emissionAngleRad = MathHelper.ToRadians(emissionAngle);
                particle.VelocityX = emissionForce * (float)Math.Sin(emissionAngleRad);
                particle.VelocityY = emissionForce * (float)-Math.Cos(emissionAngleRad);
            }


            // **********************************************************************************************************************
            // Calculate Orientation Angle.
            // **********************************************************************************************************************

            switch (_emitterData.ParticleOrientation)
            {
                // Aligned.
                case T2DParticleEmitterData.ParticleOrientationMode.Aligned:
                    {
                        // Use the emission angle plus offset.
                        particle.RotationAngle = (emissionAngle + _emitterData.OrientationAngleOffset) % 360.0f;

                    } break;

                // Fixed.
                case T2DParticleEmitterData.ParticleOrientationMode.Fixed:
                    {
                        // Use fixed angle.
                        particle.RotationAngle = _emitterData.OrientationAngleOffset % 360.0f;

                    } break;

                // Random.
                case T2DParticleEmitterData.ParticleOrientationMode.Random:
                    {
                        float halfRandomArc = _emitterData.OrientationRandomArc * 0.5f;
                        // Use the emission angle plus offset.
                        particle.RotationAngle = TorqueUtil.GetFastRandomFloat(_emitterData.OrientationAngleOffset - halfRandomArc, _emitterData.OrientationAngleOffset + halfRandomArc) % 360.0f;

                    } break;
            }
        }



        /// <summary>
        /// Update given particle over passed time interval, in seconds.
        /// </summary>
        /// <param name="particle">Particle to integrate.</param>
        /// <param name="dt">Amount to advance time, in seconds.</param>
        public void IntegrateParticle(ref T2DParticle particle, float dt)
        {
            // Increase particle age.
            particle.Age += dt;

            // Calculate Particle unit-age.
            float unitAge = particle.Age / particle.Lifetime;


            // **********************************************************************************************************************
            // Scale Speed.
            // **********************************************************************************************************************

            float renderSpeed = particle._speed * _emitterData.SpeedLife[unitAge];


            // **********************************************************************************************************************
            // Scale Fixed-Force.
            // **********************************************************************************************************************

            float renderFixedForce = particle._fixedForce * _emitterData.FixedForceLife[unitAge];


            // **********************************************************************************************************************
            // Scale Random-Motion.
            // **********************************************************************************************************************

            float renderRandomMotion = particle._randomMotion * _emitterData.RandomMotionLife[unitAge];


            // **********************************************************************************************************************
            // Calculate New Velocity...
            // **********************************************************************************************************************

            // Is random motion non-zero?
            if (Epsilon.FloatIsNotZero(renderRandomMotion))
            {
                // Yes, so fetch half random motion.
                float randomMotion = renderRandomMotion * 0.5f;

                // Add integrated random motion into velocity.
                particle._velocity.X += TorqueUtil.GetFastRandomFloat(-randomMotion, randomMotion) * dt;
                particle._velocity.Y += TorqueUtil.GetFastRandomFloat(-randomMotion, randomMotion) * dt;
            }


            Vector2 outVel;

            // Add integrated fixed force into velocity.
            //particle._velocity += _emitterData.FixedForceDirection * renderFixedForce * dt;
            Vector2 dir = _emitterData.FixedForceDirection;
            Vector2.Multiply(ref dir, renderFixedForce * dt, out outVel);
            Vector2.Add(ref outVel, ref particle._velocity, out particle._velocity);

            // Adjust particle position.
            //particle._position += particle._velocity * renderSpeed * dt;
            Vector2.Multiply(ref particle._velocity, renderSpeed * dt, out outVel);
            Vector2.Add(ref outVel, ref particle._position, out particle._position);


            // **********************************************************************************************************************
            // Aligning to motion.
            // **********************************************************************************************************************

            // Are we aligning to motion?
            if (_emitterData.ParticleOrientation == T2DParticleEmitterData.ParticleOrientationMode.Aligned)
            {
                // Yes, so calculate last movement direction.
                float movementAngle = T2DVectorUtil.AngleFromVector(particle._velocity);

                // Set new Orientation Angle.
                particle._rotationAngle = movementAngle + _emitterData.OrientationAngleOffset;
            }
            else
            {
                // Calculate render spin.
                float renderSpin = particle._spin * _emitterData.SpinLife[unitAge];

                // Have we got some spin?
                if (Epsilon.FloatIsNotZero(renderSpin))
                {
                    // Yes, so add integrated spin into orientation.
                    particle._rotationAngle += renderSpin * dt;
                    // Keep within bounds.
                    particle._rotationAngle %= 360.0f;
                }
            }


            // **********************************************************************************************************************
            // Update emitter clip boundary
            // **********************************************************************************************************************

            //Vector2 renderSize = particle._size * _maxParticleSize;
            Vector2 renderSize;
            Vector2.Multiply(ref particle._size, ref _maxParticleSize, out renderSize);

            Vector2 center = particle._position;

            // compute upper bound for maximum extent from center
            float radius = renderSize.X + renderSize.Y;
            radius += Math.Abs(_emitterData.ParticlePivotPoint.X) * _maxParticleSize.X;
            radius += Math.Abs(_emitterData.ParticlePivotPoint.Y) * _maxParticleSize.Y;
            if (center.X - radius < _particleExtentTopLeft.X)
                _particleExtentTopLeft.X = center.X - radius;
            if (center.X + radius > _particleExtentBottomRight.X)
                _particleExtentBottomRight.X = center.X + radius;
            if (center.Y - radius < _particleExtentTopLeft.Y)
                _particleExtentTopLeft.Y = center.Y - radius;
            if (center.Y + radius > _particleExtentBottomRight.Y)
                _particleExtentBottomRight.Y = center.Y + radius;
        }



        /// <summary>
        /// Start emitter.
        /// </summary>
        /// <param name="clearParticles">If true, then clear particles already allocated.</param>
        public void PlayEmitter(bool clearParticles)
        {
            // Sanity!
            Debug.Assert(CurrentEmitterData != null, "Cannot Play Emitter; no emitter-data!");

            // Reset Timer Generation Overflow.
            _timeGenerationOverflow = CurrentEmitterData.InitialAge;

            // Clear Particles?
            if (clearParticles)
            {
                // Yes...
                ClearParticles();
            }

            // Unpause emitter.
            _emitterPaused = false;
        }



        /// <summary>
        /// Stop emitting particles until PlayEmitter is called.
        /// </summary>
        public void PauseEmitter()
        {
            // Pause Emitter.
            _emitterPaused = true;

            // Single Particle?
            if (CurrentEmitterData.SingleParticle)
            {
                // Yes, so clear particles.
                ClearParticles();
            }
        }



        /// <summary>
        /// Advance time on all particles in the emitter.
        /// </summary>
        /// <param name="dt">Time to advance, in seconds.</param>
        public void AdvanceEmitterTime(float dt)
        {
            // Any emitter-data?
            if (CurrentEmitterData == null)
            {
                // No, so finish here.
                return;
            }

            // Has any time elapsed?
            if (dt <= Single.Epsilon)
            {
                // No, so finish here.
                return;
            }

            // Reset Emitter Extents.
            _particleExtentTopLeft = _parentEffect.Position;
            _particleExtentBottomRight = _parentEffect.Position;

            // **********************************************************************************************************************
            // Generate New Particles.
            // **********************************************************************************************************************

            // Only generate particle if we're not paused.
            if (!_emitterPaused)
            {
                // Are we in single-particle mode (and need a single particle)?
                if (CurrentEmitterData.SingleParticle && Allocated == 0)
                {
                    // Yes, so create single particle.
                    CreateParticles(1);
                }
                else
                {
                    // Fetch Effect Age.
                    float effectAge = _parentEffect.Age;
                    // Fetch Effect Position.
                    Vector2 effectPosition = _parentEffect.Position;

                    // Accumulate Last Generation Time as we need to handle very small time-integrations correctly.
                    //
                    // NOTE:-   We need to do this if there's an emission target but the time-integration is so
                    //          small that rounding results in no emission.
                    _timeGenerationOverflow += dt;

                    // Calculate Local Emission Quantity.
                    float baseEmission = _emitterData.QuantityBase[effectAge];
                    float varEmission = _emitterData.QuantityVariation[effectAge] * 0.5f;
                    float effectEmission = _parentEffect.CurrentEffectData.QuantityScale[effectAge];

                    float localEmission = (baseEmission + TorqueUtil.GetFastRandomFloat(-varEmission, varEmission)) * effectEmission;
                    // Inline Clamp.
                    if (localEmission < 0.0f)
                    {
                        localEmission = 0.0f;
                    }
                    int emission = (int)Math.Floor(localEmission * _timeGenerationOverflow);

                    // Do we have an emission?
                    if (emission > 0)
                    {
                        // Yes, so remove this emission from the accumulated time.
                        _timeGenerationOverflow = Math.Max(0.0f, _timeGenerationOverflow - (emission / localEmission));

                        // Suppress precision errors.
                        if (Epsilon.FloatIsZero(_timeGenerationOverflow))
                        {
                            _timeGenerationOverflow = 0.0f;
                        }

                        // Generate particles.
                        CreateParticles(emission);
                    }
                }
            }

            // **********************************************************************************************************************
            // Integrate Particles.
            // **********************************************************************************************************************

            // Are any particles allocated?
            if (Allocated > 0)
            {
                // Sanity!
                Assert.Fatal(Head != T2DParticleManager.NodeEndMarker, "Particles allocated but none in chain!");

                // Fetch Particle Manager Pool.
                T2DParticle[] particleManagerPool = T2DParticleManager.Instance.Pool;

                // No, so fetch current index.
                int currentIndex = Head;
                int nextIndex;

                // Iterate all allocated particles.
                while (currentIndex != T2DParticleManager.NodeEndMarker)
                {
                    // Integrate Particle.
                    IntegrateParticle(ref particleManagerPool[currentIndex], dt);

                    // Fetch next reference.
                    nextIndex = particleManagerPool[currentIndex].Next;

                    // Has particle expired?
                    if (particleManagerPool[currentIndex].Age > particleManagerPool[currentIndex].Lifetime)
                    {
                        // Free Particle.
                        T2DParticleManager.Instance.FreeParticle(currentIndex, this);
                    }

                    // Set to next index.
                    currentIndex = nextIndex;
                }
            }


            // Attach Position to emitter?
            if (CurrentEmitterData.AttachPositionToEmitter)
            {
                // Yes, so fetch Effect Position.
                Vector2 effectPosition = _parentEffect.Position;

                // Attach Rotation to emitter?
                if (CurrentEmitterData.AttachRotationToEmitter)
                {
                    // Yes, so we need to create rotation/translation transform.
                    _particleRotation = Matrix.CreateRotationZ((float)MathHelper.ToRadians(_parentEffect.Rotation));
                    _particleRenderTransform = _particleRotation * Matrix.CreateTranslation(effectPosition.X, effectPosition.Y, _parentEffect.LayerDepth);
                }
                else
                {
                    // No, so we need to create translation transform only.
                    _particleRotation = Matrix.Identity;
                    _particleRenderTransform = Matrix.CreateTranslation(effectPosition.X, effectPosition.Y, _parentEffect.LayerDepth);
                }

                // Calculate Top/Right and Bottom/Left Corners.
                Vector2 extentTopRight = new Vector2();
                Vector2 extentBottomLeft = new Vector2();
                extentBottomLeft.X = _particleExtentTopLeft.X;
                extentBottomLeft.Y = _particleExtentBottomRight.Y;
                extentTopRight.X = _particleExtentBottomRight.X;
                extentTopRight.Y = _particleExtentTopLeft.Y;

                // Transform into render space.
                Vector2 renderTopLeft = Vector2.Transform(_particleExtentTopLeft, ParticleRenderTransform);
                Vector2 renderBottomRight = Vector2.Transform(_particleExtentBottomRight, ParticleRenderTransform);
                Vector2 renderTopRight = Vector2.Transform(extentTopRight, ParticleRenderTransform);
                Vector2 renderBottomLeft = Vector2.Transform(extentBottomLeft, ParticleRenderTransform);

                // Calculate final particle extents.
                _particleExtentTopLeft.X = Math.Min(Math.Min(renderTopLeft.X, renderTopRight.X), Math.Min(renderBottomLeft.X, renderBottomRight.X));
                _particleExtentTopLeft.Y = Math.Min(Math.Min(renderTopLeft.Y, renderTopRight.Y), Math.Min(renderBottomLeft.Y, renderBottomRight.Y));
                _particleExtentBottomRight.X = Math.Max(Math.Max(renderTopLeft.X, renderTopRight.X), Math.Max(renderBottomLeft.X, renderBottomRight.X));
                _particleExtentBottomRight.Y = Math.Max(Math.Max(renderTopLeft.Y, renderTopRight.Y), Math.Max(renderBottomLeft.Y, renderBottomRight.Y));
            }
            else
            {
                // No, so reset Particle Render Transform.
                _particleRotation = _particleRenderTransform = Matrix.Identity;
                _particleRenderTransform.M43 = _parentEffect.LayerDepth;

                // Fetch Effect Position.
                Vector2 effectPosition = _parentEffect.Position;

                // Calculate Top/Right and Bottom/Left Corners.
                Vector2 extentTopRight;
                Vector2 extentBottomLeft;
                extentBottomLeft.X = _particleExtentTopLeft.X;
                extentBottomLeft.Y = _particleExtentBottomRight.Y;
                extentTopRight.X = _particleExtentBottomRight.X;
                extentTopRight.Y = _particleExtentTopLeft.Y;

                // Calculate final particle extents.
                _particleExtentTopLeft.X = Math.Min(Math.Min(_particleExtentTopLeft.X, extentTopRight.X), Math.Min(extentBottomLeft.X, extentBottomLeft.X));
                _particleExtentTopLeft.Y = Math.Min(Math.Min(_particleExtentTopLeft.Y, extentTopRight.Y), Math.Min(extentBottomLeft.Y, extentBottomLeft.Y));
                _particleExtentBottomRight.X = Math.Max(Math.Max(_particleExtentTopLeft.X, extentTopRight.X), Math.Max(extentBottomLeft.X, extentBottomLeft.X));
                _particleExtentBottomRight.Y = Math.Max(Math.Max(_particleExtentTopLeft.Y, extentTopRight.Y), Math.Max(extentBottomLeft.Y, extentBottomLeft.Y));
            }
        }



        /// <summary>
        /// Render all the particles in the emitter.  This method is called by particle effects
        /// and should not normally be called otherwise.
        /// </summary>
        /// <param name="vertexScratch">Scratch space for vertices.  Must contain enough space for all particles to be rendered.</param>
        /// <param name="vertexOffset">Offset into vertex scratch space for first vertex.  Will be udpated for later particles.</param>
        /// <param name="textureCoords">Array of texture coords.</param>
        /// <param name="normal">Precomputed normal for particle.</param>
        /// <param name="tangent">Precomputed tangent for particle.</param>
        public void RenderEmitter(GFXVertexFormat.PCTTBN[] vertexScratch,
                                    ref int vertexOffset,
                                    Vector2[] textureCoords,
                                    ref Vector4 normal,
                                    ref Vector4 tangent)
        {
            // Any emitter-data or Allocated Particles?
            if (CurrentEmitterData == null || Allocated == 0)
                return;

            // Sanity!
            Assert.Fatal(Head != T2DParticleManager.NodeEndMarker, "Particles allocated but none in emitter chain!");

            // Fetch Particle Manager Pool.
            T2DParticle[] particleManagerPool = T2DParticleManager.Instance.Pool;

            // Fetch Particle Count.
            int particleCount = Allocated;

            // Note Vertex base.
            int vertexBase = vertexOffset;

            // Fetch current index.
            int currentIndex = CurrentEmitterData.FirstInFrontOrder ? Tail : Head;

            // no need to dereference these more than once
            Vector2 pivot = _emitterData.ParticlePivotPoint;
            T2DKeyGraph redLife = _emitterData.RedChannelLife;
            T2DKeyGraph greenLife = _emitterData.GreenChannelLife;
            T2DKeyGraph blueLife = _emitterData.BlueChannelLife;
            T2DKeyGraph visibilityLife = _emitterData.VisibilityLife;
            T2DKeyGraph visibilityScale = _parentEffect.CurrentEffectData.VisibilityScale;

            // Iterate all allocated particles.
            while (currentIndex != -1)
            {
                // Calculate Particle unit-age, so that we can get size
                float unitAge = particleManagerPool[currentIndex].Age / particleManagerPool[currentIndex].Lifetime;

                // Scale Size
                //Vector2 renderSize = 0.5f * particleManagerPool[currentIndex]._size;
                Vector2 renderSize;
                Vector2.Multiply(ref particleManagerPool[currentIndex]._size, 0.5f, out renderSize);

                renderSize.X *= _emitterData.SizeXLife[unitAge];
                if (renderSize.X < 0.0f)
                    renderSize.X = 0.0f;
                if (_emitterData.FixedParticleAspect)
                    renderSize.Y = renderSize.X;
                else
                {
                    renderSize.Y *= _emitterData.SizeYLife[unitAge];
                    if (renderSize.Y < 0.0f)
                        renderSize.Y = 0.0f;
                }

                // Transform Particle, inline the math.
                Rotation2D rotation = new Rotation2D(MathHelper.ToRadians(particleManagerPool[currentIndex]._rotationAngle));

                //Vector2 center = particleManagerPool[currentIndex]._position + renderSize * pivot - rotation.Rotate(renderSize * pivot);
                Vector2 center;
                Vector2.Multiply(ref renderSize, ref pivot, out center);
                Vector2 rotate = rotation.Rotate(center);
                Vector2.Subtract(ref center, ref rotate, out center);
                Vector2.Add(ref particleManagerPool[currentIndex]._position, ref center, out center);

                //Vector2 x = renderSize.X * rotation.X;
                //Vector2 y = renderSize.Y * rotation.Y;
                Vector2 x, y;
                Vector2 rotX = rotation.X, rotY = rotation.Y;
                float renX = renderSize.X, renY = renderSize.Y;
                Vector2.Multiply(ref rotX, renX, out x);
                Vector2.Multiply(ref rotY, renY, out y);


                // Get the color for this particle
                float redValue = redLife[unitAge];
                float greenValue = greenLife[unitAge];
                float blueValue = blueLife[unitAge];
                float visibilityValue = visibilityLife[unitAge] * visibilityScale[unitAge];
                Color color = new Color((byte)(redValue * 255.0f), (byte)(greenValue * 255.0f), (byte)(blueValue * 255.0f), (byte)(visibilityValue * 255.0f));

                // Vertex #0.
                vertexScratch[vertexOffset++] = new GFXVertexFormat.PCTTBN(new Vector3(-x.X - y.X + center.X, -x.Y - y.Y + center.Y, 0.0f),
                                                                            color,
                                                                            textureCoords[0],
                                                                            new Vector2(0.0f, 0.0f),
                                                                            tangent, normal);

                // Vertex #1.
                vertexScratch[vertexOffset++] = new GFXVertexFormat.PCTTBN(new Vector3(x.X - y.X + center.X, x.Y - y.Y + center.Y, 0.0f),
                                                                            color,
                                                                            textureCoords[1],
                                                                            new Vector2(0.0f, 0.0f),
                                                                            tangent, normal);

                // Vertex #2.
                vertexScratch[vertexOffset++] = new GFXVertexFormat.PCTTBN(new Vector3(x.X + y.X + center.X, x.Y + y.Y + center.Y, 0.0f),
                                                                            color,
                                                                            textureCoords[2],
                                                                            new Vector2(0.0f, 0.0f),
                                                                            tangent, normal);

                // Vertex #3.
                vertexScratch[vertexOffset++] = new GFXVertexFormat.PCTTBN(new Vector3(y.X - x.X + center.X, y.Y - x.Y + center.Y, 0.0f),
                                                                            color,
                                                                            textureCoords[3],
                                                                            new Vector2(0.0f, 0.0f),
                                                                            tangent, normal);

                // Set to next index.
                currentIndex = CurrentEmitterData.FirstInFrontOrder ? particleManagerPool[currentIndex].Previous : particleManagerPool[currentIndex].Next;
            }
        }

        #endregion


        #region Private, protected, internal methods

        void _FindMaxParticleSize()
        {
            if (_emitterData == null)
                return;

            // Find the largest particle possible (before scaling by per particle size)
            // Note: this belongs on emitter data, but this way we know the value is at
            // least as recent as when we compute this (when emitter data set on emitter).

            _maxParticleSize.X = _emitterData.SizeXLife.DefaultValue;
            for (int i = 0; i < _emitterData.SizeXLife.Count; i++)
                _maxParticleSize.X = Math.Max(_maxParticleSize.X, _emitterData.SizeXLife.GetKeyValue(i));

            _maxParticleSize.Y = _emitterData.SizeYLife.DefaultValue;
            for (int i = 0; i < _emitterData.SizeYLife.Count; i++)
                _maxParticleSize.Y = Math.Max(_maxParticleSize.Y, _emitterData.SizeYLife.GetKeyValue(i));
        }



        bool _CheckLifeTime()
        {
            // make sure min lifetime is legit
            T2DKeyGraph lifeBase = _emitterData.ParticleLifeBase;
            float minLifeTime = lifeBase.DefaultValue;
            for (int i = 0; i < lifeBase.Count; i++)
                minLifeTime = Math.Min(minLifeTime, lifeBase.GetKeyValue(i));

            float maxLifeScale = 1.0f;
            if (_parentEffect != null)
            {
                T2DKeyGraph lifeScale = _parentEffect.CurrentEffectData.ParticleLifeScale;
                maxLifeScale = lifeScale.DefaultValue;
                for (int i = 0; i < lifeScale.Count; i++)
                    maxLifeScale = Math.Max(maxLifeScale, lifeScale.GetKeyValue(i));
            }

            T2DKeyGraph lifeVar = _emitterData.ParticleLifeVariation;
            float maxLifeVar = lifeVar.DefaultValue;
            for (int i = 0; i < lifeVar.Count; i++)
                maxLifeVar = Math.Max(maxLifeVar, lifeVar.GetKeyValue(i));

            return minLifeTime - 0.5f * maxLifeScale * maxLifeVar > 0.0f;
        }

        #endregion


        #region Private, protected, internal fields

        private T2DParticleEmitterData _emitterData;

        // Parent Effect.
        private T2DParticleEffect _parentEffect;

        // Particle Generation.
        private float _timeGenerationOverflow;
        private bool _emitterPaused = false;

        // IIndexPoolerChain.
        private int _allocatedPoolCount = 0;
        private int _freeHeadIndex = IndexPooler<T2DParticle>.NodeEndMarker;
        private int _freeTailIndex = IndexPooler<T2DParticle>.NodeEndMarker;

        // Emitter Extents.
        Vector2 _particleExtentTopLeft;
        Vector2 _particleExtentBottomRight;
        Vector2 _maxParticleSize;

        // Particle Render Transform.
        Matrix _particleRenderTransform = Matrix.Identity;
        Matrix _particleRotation = Matrix.Identity;

        #endregion

        #region IDisposable Members

        public void Dispose()
        {
            ClearParticles();
            _emitterData = null;
            _parentEffect = null;
        }

        #endregion
    }
}

